.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Test::Stream::Plugin::Spec 3"
.TH Test::Stream::Plugin::Spec 3 "2015-10-13" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Test::Stream::Plugin::Spec \- SPEC testing tools
.SH "EXPERIMENTAL CODE WARNING"
.IX Header "EXPERIMENTAL CODE WARNING"
\&\fBThis is an experimental release!\fR Test-Stream, and all its components are
still in an experimental phase. This dist has been released to cpan in order to
allow testers and early adopters the chance to write experimental new tools
with it, or to add experimental support for it into old tools.
.PP
\&\fB\s-1PLEASE DO NOT COMPLETELY CONVERT OLD TOOLS YET\s0\fR. This experimental release is
very likely to see a lot of code churn. \s-1API\s0's may break at any time.
Test-Stream should \s-1NOT\s0 be depended on by any toolchain level tools until the
experimental phase is over.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Test::Stream qw/\-V1 Spec/
\&
\&    describe fruit_shipment => sub {
\&        my $crates;
\&        before_all unload_crates => sub { $crates = get_crates() };
\&        after_all deliver_crates => sub { deliver($crates) };
\&
\&        my $fruit;
\&        for my $f ($crates\->types) { # \*(Aqpear\*(Aq and \*(Aqapple\*(Aq
\&            case $f => sub { $fruit = $f };
\&        }
\&
\&        my $crate;
\&        before_each open_crate => sub { $crate = $crates\->open_first($fruit) };
\&        after_each close_crate => sub { $crates\->store($crate) };
\&
\&        tests squishability => sub {
\&            my $sample = $crate\->grab();
\&            ok($sample\->squishability > 5, "squish rating is greater than 5");
\&            ok($sample\->squishability < 10, "squish rating is less than 10");
\&        };
\&
\&        tests flavor => sub {
\&            my $sample = $crate\->grab();
\&            ok($sample\->is_tasty, "sample is tasty");
\&            ok(!$sample\->is_sour, "sample is not sour");
\&        };
\&
\&        tests ripeness => sub {
\&            my $sample1 = $crate\->grab();
\&            my $sample2 = $crate\->grab();
\&
\&            my $overripe  = grep { $_\->is_overripe }  $sample1, $sample2;
\&            my $underripe = grep { $_\->is_underripe } $sample1, $sample2;
\&
\&            ok($overripe  < 2, "at least 1 sample is not overripe");
\&            ok($underripe < 2, "at least 1 sample is not underripe");
\&        };
\&    };
\&
\&    done_testing;
.Ve
.PP
In this sample we are describing a fruit shipment. Before anything else we
unload the crates. Next we handle 2 types of fruit, a crate of pears and a
crate of apples. For each create we need to run tests on squishability, flavor,
and ripeness. In order to run these tests the creates need to be opened, when
the tests are done the crates need to be closed again.
.PP
We use the before_all and after_all to specify the first and last tasks to be
run, each one will run exactly once. The 3 sets of tests will be run once per
fruit type, we have cases for pears and apples, so in total there will be 6
sets of tests run, 3 per fruit type. Opening and closing the crate is something
we need to do for each test block, so we use before_each and after_each.
.PP
Each test block needs unique samples, so the sample is aquired within the test.
We do not use a before_each as some tests require different numbers of samples.
.SH "EXPORTS"
.IX Header "EXPORTS"
All exports have the exact same syntax, there are 2 forms:
.PP
.Vb 2
\&    FUNCTION($NAME, \e&CODE);
\&    FUNCTION($NAME, \e%PARAMS, \e&CODE);
.Ve
.PP
Both can also be used in a style that is more pleasingto the eye:
.PP
.Vb 2
\&    FUNCTION $NAME => sub { ... };
\&    FUNCTION $NAME => {...}, sub { ... }
.Ve
.PP
The name and codeblock are required. Optionally you can provide a hashref
of parameters between the name and coderef with parameters. Valid parameters
depends on what runner is used, but the parameters supported by default are:
.PP
\&\fBNote:\fR The default runner is Test::Stream::Workflow::Runner.
.IP "todo => 'reason'" 4
.IX Item "todo => 'reason'"
This will mark the entire block as todo with the given reason. This parameter
is inherited by nested blocks.
.IP "skip => 'reason'" 4
.IX Item "skip => 'reason'"
This will skip the entire block, it will generate a single 'Ok' event with the
skip reason set.
.ie n .IP "iso => $bool" 4
.el .IP "iso => \f(CW$bool\fR" 4
.IX Item "iso => $bool"
.PD 0
.ie n .IP "isolate => $bool" 4
.el .IP "isolate => \f(CW$bool\fR" 4
.IX Item "isolate => $bool"
.PD
This tells the runner to isolate the task before running the block. This allows
you to isolate blocks that may modify state in ways that should not be seen by
later tests. Isolation is achieved either by forking, or by spawning a child
thread, depending on the platform. If no isolation method is available the
block will simply be skipped.
.Sp
\&\fB\s-1CAVEAT:\s0\fR Since the isolation may be threads (specially if you are on windows)
it may fail to isolate shared variables. If you use variables that are shared
between threads you cannot rely on this isolation mechanism.
.PP
\&\fBNote:\fR The tests you declare are deferred, that is they run after everything
else is done, typically when you call \f(CW\*(C`done_testing\*(C'\fR.
.SS "\s-1TEST DECLARATIONS\s0"
.IX Subsection "TEST DECLARATIONS"
Test declarations are used to declare blocks of tests. You can put pretty much
anything you want inside a test block, the only exceptions to this is that
other test blocks, groups, modifiers, etc, cannot be specified inside the test
block.
.PP
If a test block does not produce any events then it will be considered an
error. Test blocks are run as subtests.
.ie n .IP "tests $name => sub { ... }" 4
.el .IP "tests \f(CW$name\fR => sub { ... }" 4
.IX Item "tests $name => sub { ... }"
.PD 0
.ie n .IP "it $name => sub { ... }" 4
.el .IP "it \f(CW$name\fR => sub { ... }" 4
.IX Item "it $name => sub { ... }"
.ie n .IP "tests $name => \e%params, sub { ... }" 4
.el .IP "tests \f(CW$name\fR => \e%params, sub { ... }" 4
.IX Item "tests $name => %params, sub { ... }"
.ie n .IP "it $name => \e%params, sub { ... }" 4
.el .IP "it \f(CW$name\fR => \e%params, sub { ... }" 4
.IX Item "it $name => %params, sub { ... }"
.PD
\&\f(CW\*(C`tests()\*(C'\fR and \f(CW\*(C`it()\*(C'\fR are both aliases to the same function. The name
\&\f(CW\*(C`tests()\*(C'\fR is present as the authors preference. \f(CW\*(C`it()\*(C'\fR is present to reflect
the name used in \s-1RSPEC\s0 for the Ruby programming language.
.Sp
\&\fBNote:\fR The subs get no arguments, and their return is ignored.
.SS "\s-1TEST SETUP AND TEARDOWN\s0"
.IX Subsection "TEST SETUP AND TEARDOWN"
These blocks attach themselves to test blocks. The setup/teardown will run once
for each test block. These are all inherited by test blocks declared in nested
groups.
.ie n .IP "before_each $name => sub { ... }" 4
.el .IP "before_each \f(CW$name\fR => sub { ... }" 4
.IX Item "before_each $name => sub { ... }"
Declare a setup that will run before each test block is run. \fBNote:\fR This will
run before any modifier.
.Sp
\&\fBNote:\fR The subs get no arguments, and their return is ignored.
.ie n .IP "after_each $name => sub { ... }" 4
.el .IP "after_each \f(CW$name\fR => sub { ... }" 4
.IX Item "after_each $name => sub { ... }"
Declare a teardown that will run after each test block.
.Sp
\&\fBNote:\fR The subs get no arguments, and their return is ignored.
.ie n .IP "around_each $name => sub { ... }" 4
.el .IP "around_each \f(CW$name\fR => sub { ... }" 4
.IX Item "around_each $name => sub { ... }"
Declare a setup+teardown that is wrapped around the test block. This is useful
if you want to localize a variable, or something similar.
.Sp
.Vb 2
\&    around_each foo => sub {
\&        my $inner = shift;
\&
\&        local %ENV;
\&
\&        # You need to call the \*(Aqinner\*(Aq sub.
\&        $inner\->();
\&    };
.Ve
.Sp
\&\fBNote:\fR The subs get no arguments, and their return is ignored.
.SS "\s-1TEST MODIFIERS\s0"
.IX Subsection "TEST MODIFIERS"
.ie n .IP "case $name => sub { ... }" 4
.el .IP "case \f(CW$name\fR => sub { ... }" 4
.IX Item "case $name => sub { ... }"
You can specify any number of cases that should be used. All test blocks are
run once per case. Cases are inherited by nested groups.
.Sp
\&\fBNote:\fR The subs get no arguments, and their return is ignored.
.PP
\fI\s-1TEST MODIFIER SETUP AND TEARDOWN\s0\fR
.IX Subsection "TEST MODIFIER SETUP AND TEARDOWN"
.ie n .IP "before_case $name => sub { ... }" 4
.el .IP "before_case \f(CW$name\fR => sub { ... }" 4
.IX Item "before_case $name => sub { ... }"
Code to be run just before a case is run.
.Sp
\&\fBNote:\fR The subs get no arguments, and their return is ignored.
.ie n .IP "after_case $name => sub { ... }" 4
.el .IP "after_case \f(CW$name\fR => sub { ... }" 4
.IX Item "after_case $name => sub { ... }"
Code to be run just after a case is run (but before the test block).
.Sp
\&\fBNote:\fR The subs get no arguments, and their return is ignored.
.ie n .IP "around_case $name => sub { ... }" 4
.el .IP "around_case \f(CW$name\fR => sub { ... }" 4
.IX Item "around_case $name => sub { ... }"
Code that wraps around the case.
.Sp
.Vb 2
\&    around_case foo => sub {
\&        my $inner = shift;
\&
\&        local %ENV;
\&
\&        # You need to call the \*(Aqinner\*(Aq sub.
\&        $inner\->();
\&    };
.Ve
.Sp
\&\fBNote:\fR The subs get no arguments, and their return is ignored.
.SS "\s-1TEST GROUPS\s0"
.IX Subsection "TEST GROUPS"
.ie n .IP "describe $name => sub { ... }" 4
.el .IP "describe \f(CW$name\fR => sub { ... }" 4
.IX Item "describe $name => sub { ... }"
.PD 0
.ie n .IP "cases $name => sub { ... }" 4
.el .IP "cases \f(CW$name\fR => sub { ... }" 4
.IX Item "cases $name => sub { ... }"
.PD
\&\f(CW\*(C`describe()\*(C'\fR and \f(CW\*(C`cases()\*(C'\fR are both aliases to the same thing.
.Sp
These can be used to create groups of test block along with setup/teardown
subs. The cases, setups, and teardowns will not effect test blocks outside the
group. All cases, setups, and teardown will be inherited by any nested group.
.Sp
\&\fBNote:\fR Group subs are run as they are encountered, unlike test blocks which
are run at the very end of the test script.
.Sp
\&\fBNote:\fR The subs get no arguments, and their return is ignored.
.SS "\s-1GROUP MODIFIERS\s0"
.IX Subsection "GROUP MODIFIERS"
.ie n .IP "before_all $name => sub { ... }" 4
.el .IP "before_all \f(CW$name\fR => sub { ... }" 4
.IX Item "before_all $name => sub { ... }"
Specify a setup that gets run once at the start of the test group.
.Sp
\&\fBNote:\fR The subs get no arguments, and their return is ignored.
.ie n .IP "after_all $name => sub { ... }" 4
.el .IP "after_all \f(CW$name\fR => sub { ... }" 4
.IX Item "after_all $name => sub { ... }"
Specify a teardown that gets run once at the end of the test group.
.Sp
\&\fBNote:\fR The subs get no arguments, and their return is ignored.
.ie n .IP "around_all $name => sub { ... }" 4
.el .IP "around_all \f(CW$name\fR => sub { ... }" 4
.IX Item "around_all $name => sub { ... }"
Specify a teardown that gets run once, around the test group.
.Sp
.Vb 2
\&    around_all foo => sub {
\&        my $inner = shift;
\&
\&        local %ENV;
\&
\&        # You need to call the \*(Aqinner\*(Aq sub.
\&        $inner\->();
\&    };
.Ve
.Sp
\&\fBNote:\fR The subs get no arguments, and their return is ignored.
.SH "NOTE ON RUN ORDER"
.IX Header "NOTE ON RUN ORDER"
Within a test group (the main package counts as a group) things run in this order:
.IP "group blocks (describe, cases)" 4
.IX Item "group blocks (describe, cases)"
.PD 0
.IP "\s-1END OF SCRIPT \s0(done_testing called)" 4
.IX Item "END OF SCRIPT (done_testing called)"
.IP "before_all + around_all starts" 4
.IX Item "before_all + around_all starts"
.RS 4
.IP "before_each + around_each starts" 4
.IX Item "before_each + around_each starts"
.RS 4
.IP "before_case + around_case starts" 4
.IX Item "before_case + around_case starts"
.RS 4
.IP "case" 4
.IX Item "case"
.RE
.RS 4
.RE
.IP "after_case + around_case stops" 4
.IX Item "after_case + around_case stops"
.IP "tests/it" 4
.IX Item "tests/it"
.RE
.RS 4
.RE
.IP "after_each + around_each stops" 4
.IX Item "after_each + around_each stops"
.RE
.RS 4
.RE
.IP "after_all + around_all stops" 4
.IX Item "after_all + around_all stops"
.PD
.SH "SOURCE"
.IX Header "SOURCE"
The source code repository for Test::Stream can be found at
\&\fIhttp://github.com/Test\-More/Test\-Stream/\fR.
.SH "MAINTAINERS"
.IX Header "MAINTAINERS"
.IP "Chad Granum <exodist@cpan.org>" 4
.IX Item "Chad Granum <exodist@cpan.org>"
.SH "AUTHORS"
.IX Header "AUTHORS"
.PD 0
.IP "Chad Granum <exodist@cpan.org>" 4
.IX Item "Chad Granum <exodist@cpan.org>"
.PD
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2015 Chad Granum <exodist7@gmail.com>.
.PP
This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
.PP
See \fIhttp://www.perl.com/perl/misc/Artistic.html\fR
