.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Test::Stream::Context 3"
.TH Test::Stream::Context 3 "2015-10-13" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Test::Stream::Context \- Object to represent a testing context.
.SH "EXPERIMENTAL CODE WARNING"
.IX Header "EXPERIMENTAL CODE WARNING"
\&\fBThis is an experimental release!\fR Test-Stream, and all its components are
still in an experimental phase. This dist has been released to cpan in order to
allow testers and early adopters the chance to write experimental new tools
with it, or to add experimental support for it into old tools.
.PP
\&\fB\s-1PLEASE DO NOT COMPLETELY CONVERT OLD TOOLS YET\s0\fR. This experimental release is
very likely to see a lot of code churn. \s-1API\s0's may break at any time.
Test-Stream should \s-1NOT\s0 be depended on by any toolchain level tools until the
experimental phase is over.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The context object is the primary interface for authors of testing tools
written with Test::Stream. The context object represents the context in
which a test takes place (File and Line Number), and provides a quick way to
generate events from that context. The context object also takes care of
sending events to the correct Test::Stream::Hub instance.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Test::Stream::Context qw/context release/;
\&
\&    sub my_ok {
\&        my ($bool, $name) = @_;
\&        my $ctx = context();
\&        $ctx\->ok($bool, $name);
\&        $ctx\->release; # You MUST do this!
\&        return $bool;
\&    }
.Ve
.PP
Context objects make it easy to wrap other tools that also use context. Once
you grab a context, any tool you call before releasing your context will
inherit it:
.PP
.Vb 4
\&    sub wrapper {
\&        my ($bool, $name) = @_;
\&        my $ctx = context();
\&        $ctx\->diag("wrapping my_ok");
\&
\&        my $out = my_ok($bool, $name);
\&        $ctx\->release; # You MUST do this!
\&        return $out;
\&    }
.Ve
.PP
Notice above that we are grabbing a return value, then releasing our context,
then returning the value. We can combine these last 3 statements into a single
statement using the \f(CW\*(C`release\*(C'\fR function:
.PP
.Vb 4
\&    sub wrapper {
\&        my ($bool, $name) = @_;
\&        my $ctx = context();
\&        $ctx\->diag("wrapping my_ok");
\&
\&        # You must always release the context.
\&        release $ctx, my_ok($bool, $name);
\&    }
.Ve
.SH "CRITICAL DETAILS"
.IX Header "CRITICAL DETAILS"
.IP "You \s-1MUST\s0 always release the context when done with it" 4
.IX Item "You MUST always release the context when done with it"
Releasing the context tells the system you are done with it. This gives it a
chance to run any necessary callbacks or cleanup tasks. If you forget to
release the context it will be released for you using a destructor, and it will
give you a warning.
.Sp
In general the destructor is not preferred because it does not allow callbacks
to run some types of code, for example you cannot throw an exception from a
destructor.
.IP "You \s-1MUST NOT\s0 pass context objects around" 4
.IX Item "You MUST NOT pass context objects around"
When you obtain a context object it is made specifically for your tool and any
tools nested within. If you pass a context around you run the risk of polluting
other tools with incorrect context information.
.Sp
If you are certain that you want a different tool to use the same context you
may pass it a snapshot. \f(CW\*(C`$ctx\->snapshot\*(C'\fR will give you a shallow clone of
the context that is safe to pass around or store.
.IP "You \s-1MUST NOT\s0 store or cache a context for later" 4
.IX Item "You MUST NOT store or cache a context for later"
As long as a context exists for a given hub, all tools that try to get a
context will get the existing instance. If you try to store the context you
will pollute other tools with incorrect context information.
.Sp
If you are certain that you want to save the context for later, you can use a
snapshot. \f(CW\*(C`$ctx\->snapshot\*(C'\fR will give you a shallow clone of the context
that is safe to pass around or store.
.Sp
\&\f(CW\*(C`context() has some mechanisms to protect you if you do cause a context to
persist beyond the scope in which it was obtained. In practice you should not
rely on these protections, and they are fairly noisy with warnings.\*(C'\fR
.IP "You \s-1SHOULD\s0 obtain your context as soon as possible in a given tool" 4
.IX Item "You SHOULD obtain your context as soon as possible in a given tool"
You never know what tools you call from within your own tool will need a
context. Obtaining the context early ensures that nested tools can find the
context you want them to find.
.SH "EXPORTS"
.IX Header "EXPORTS"
All exports are optional, you must specify subs to import. If you want to
import all subs use '\-all'.
.PP
.Vb 1
\&    use Test::Stream::Context \*(Aq\-all\*(Aq;
.Ve
.SS "\fIcontext()\fP"
.IX Subsection "context()"
Usage:
.ie n .IP "$ctx = \fIcontext()\fR" 4
.el .IP "\f(CW$ctx\fR = \fIcontext()\fR" 4
.IX Item "$ctx = context()"
.PD 0
.ie n .IP "$ctx = context(%params)" 4
.el .IP "\f(CW$ctx\fR = context(%params)" 4
.IX Item "$ctx = context(%params)"
.PD
.PP
The \f(CW\*(C`context()\*(C'\fR function will always return the current context to you. If
there is already a context active it will be returned. If there is not an
active context one will be generated. When a context is generated it will
default to using the file and line number where the currently running sub was
called from.
.PP
Please see the \*(L"\s-1CRITICAL DETAILS\*(R"\s0 section for important rools about what
you can and acannot do with a context once it is obtained.
.PP
\&\fBNote\fR This function will throw an exception if you ignore the context object
it returns.
.PP
\fI\s-1OPTIONAL PARAMETERS\s0\fR
.IX Subsection "OPTIONAL PARAMETERS"
.PP
All parameters to \f(CW\*(C`context\*(C'\fR are optional.
.ie n .IP "level => $int" 4
.el .IP "level => \f(CW$int\fR" 4
.IX Item "level => $int"
If you must obtain a context in a sub deper than your entry point you can use
this to tell it how many \s-1EXTRA\s0 stack frames to look back. If this option is not
provided the default of \f(CW0\fR is used.
.Sp
.Vb 6
\&    sub third_party_tool {
\&        my $sub = shift;
\&        ... # Does not obtain a context
\&        $sub\->();
\&        ...
\&    }
\&
\&    third_party_tool(sub {
\&        my $ctx = context(level => 1);
\&        ...
\&        $ctx\->release;
\&    });
.Ve
.ie n .IP "wrapped => $int" 4
.el .IP "wrapped => \f(CW$int\fR" 4
.IX Item "wrapped => $int"
Use this if you need to write your own tool that wraps a call to \f(CW\*(C`context()\*(C'\fR
with the intent that it should return a context object.
.Sp
.Vb 7
\&    sub my_context {
\&        my %params = ( wrapped => 0, @_ );
\&        $params{wrapped}++;
\&        my $ctx = context(%params);
\&        ...
\&        return $ctx;
\&    }
\&
\&    sub my_tool {
\&        my $ctx = my_context();
\&        ...
\&        $ctx\->release;
\&    }
.Ve
.Sp
If you do not do this than tools you call that also check for a context will
notice that the context they grabbed was created at the same stack depth, which
will trigger protective measures that warn you and destroy the existing
context.
.ie n .IP "stack => $stack" 4
.el .IP "stack => \f(CW$stack\fR" 4
.IX Item "stack => $stack"
Normally \f(CW\*(C`context()\*(C'\fR looks at the global hub stack initialized in
Test::Stream::Sync. If you are maintaining your own Test::Stream::Stack
instance you may pass it in to be used instead of the global one.
.ie n .IP "hub => $hub" 4
.el .IP "hub => \f(CW$hub\fR" 4
.IX Item "hub => $hub"
Use this parameter if you want to onbtain the context for a specific hub
instead of whatever one happens to be at the top of the stack.
.IP "on_init => sub { ... }" 4
.IX Item "on_init => sub { ... }"
This lets you provide a callback sub that will be called \fB\s-1ONLY\s0\fR if your call
to c<\fIcontext()\fR> generated a new context. The callback \fB\s-1WILL NOT\s0\fR be called if
\&\f(CW\*(C`context()\*(C'\fR is returning an existing context. The only argument passed into
the callback will be the context object itself.
.Sp
.Vb 2
\&    sub foo {
\&        my $ctx = context(on_init => sub { \*(Aqwill run\*(Aq });
\&
\&        my $inner = sub {
\&            # This callback is not run since we are getting the existing
\&            # context from our parent sub.
\&            my $ctx = context(on_init => sub { \*(Aqwill NOT run\*(Aq });
\&            $ctx\->release;
\&        }
\&        $inner\->();
\&
\&        $ctx\->release;
\&    }
.Ve
.IP "on_release => sub { ... }" 4
.IX Item "on_release => sub { ... }"
This lets you provide a callback sub that will be called when the context
instance is released. This callback will be added to the returned context even
if an existing context is returned. If multiple calls to context add callbacks
then all will be called in reverse order when the context is finally released.
.Sp
.Vb 2
\&    sub foo {
\&        my $ctx = context(on_release => sub { \*(Aqwill run second\*(Aq });
\&
\&        my $inner = sub {
\&            my $ctx = context(on_release => sub { \*(Aqwill run first\*(Aq });
\&
\&            # Neither callback runs on this release
\&            $ctx\->release;
\&        }
\&        $inner\->();
\&
\&        # Both callbacks run here.
\&        $ctx\->release;
\&    }
.Ve
.SS "\fIrelease()\fP"
.IX Subsection "release()"
Usage:
.ie n .IP "release $ctx;" 4
.el .IP "release \f(CW$ctx\fR;" 4
.IX Item "release $ctx;"
.PD 0
.ie n .IP "release $ctx, ...;" 4
.el .IP "release \f(CW$ctx\fR, ...;" 4
.IX Item "release $ctx, ...;"
.PD
.PP
This is intended as a shortcut that lets you release your context and return a
value in one statement. This function will get your context, and any other
arguments provided. It will release your context, then return everything else.
If you only provide one argument it will return that one argument as a scalar.
If you provide multiple arguments it will return them all as a list.
.PP
.Vb 3
\&    sub scalar_tool {
\&        my $ctx = context();
\&        ...
\&
\&        return release $ctx, 1;
\&    }
\&
\&    sub list_tool {
\&        my $ctx = context();
\&        ...
\&
\&        return release $ctx, qw/a b c/;
\&    }
.Ve
.PP
This tool is most useful when you want to return the value you get from calling
a function that needs to see the current context:
.PP
.Vb 4
\&    my $ctx = context();
\&    my $out = some_tool(...);
\&    $ctx\->release;
\&    return $out;
.Ve
.PP
We can combine the last 3 lines of the above like so:
.PP
.Vb 2
\&    my $ctx = context();
\&    release $ctx, some_tool(...);
.Ve
.SH "METHODS"
.IX Header "METHODS"
.SS "\s-1CLASS METHODS\s0"
.IX Subsection "CLASS METHODS"
.IP "Test::Stream::Context\->\s-1ON_INIT\s0(sub { ... }, ...)" 4
.IX Item "Test::Stream::Context->ON_INIT(sub { ... }, ...)"
.PD 0
.IP "Test::Stream::Context\->\s-1ON_RELEASE\s0(sub { ... }, ...)" 4
.IX Item "Test::Stream::Context->ON_RELEASE(sub { ... }, ...)"
.PD
These are \fB\s-1GLOBAL\s0\fR hooks into the context tools. Every sub added via \s-1ON_INIT\s0
will be called every single time a new context is initialized. Every sub added
via \s-1ON_RELEASE\s0 will be called every single time a context is released.
.Sp
Subs will recieve exactly 1 argument, that is the context itself. You should
not call \f(CW\*(C`release\*(C'\fR on the context within your callback.
.SS "\s-1INSTANCE METHODS\s0"
.IX Subsection "INSTANCE METHODS"
.ie n .IP "$clone = $ctx\->\fIsnapshot()\fR" 4
.el .IP "\f(CW$clone\fR = \f(CW$ctx\fR\->\fIsnapshot()\fR" 4
.IX Item "$clone = $ctx->snapshot()"
This will return a shallow clone of the context. The shallow clone is safe to
store for later.
.ie n .IP "$ctx\->\fIrelease()\fR" 4
.el .IP "\f(CW$ctx\fR\->\fIrelease()\fR" 4
.IX Item "$ctx->release()"
This will release the context. It will also set the \f(CW$ctx\fR variable to
\&\f(CW\*(C`undef\*(C'\fR (it works regardless of what you name the variable).
.ie n .IP "$ctx\->throw($message)" 4
.el .IP "\f(CW$ctx\fR\->throw($message)" 4
.IX Item "$ctx->throw($message)"
This will throw an exception reporting to the file and line number of the
context. This will also release the context for you.
.ie n .IP "$ctx\->alert($message)" 4
.el .IP "\f(CW$ctx\fR\->alert($message)" 4
.IX Item "$ctx->alert($message)"
This will issue a warning from the file and line number of the context.
.ie n .IP "$stack = $ctx\->\fIstack()\fR" 4
.el .IP "\f(CW$stack\fR = \f(CW$ctx\fR\->\fIstack()\fR" 4
.IX Item "$stack = $ctx->stack()"
This will return the Test::Stream::Stack instance the context used to find
the current hub.
.ie n .IP "$hub = $ctx\->\fIhub()\fR" 4
.el .IP "\f(CW$hub\fR = \f(CW$ctx\fR\->\fIhub()\fR" 4
.IX Item "$hub = $ctx->hub()"
This will return the Test::Stream::Hub instance the context recognises as
the current one to which all events should be sent.
.ie n .IP "$dbg = $ctx\->\fIdebug()\fR" 4
.el .IP "\f(CW$dbg\fR = \f(CW$ctx\fR\->\fIdebug()\fR" 4
.IX Item "$dbg = $ctx->debug()"
This will return the Test::Stream::DebugInfo instance used by the context.
.ie n .IP "$ctx\->do_in_context(\e&code, @args);" 4
.el .IP "\f(CW$ctx\fR\->do_in_context(\e&code, \f(CW@args\fR);" 4
.IX Item "$ctx->do_in_context(&code, @args);"
Sometimes you have a context that is not current, and you want things to use it
as the current one. In these cases you can call
\&\*(L"$ctx\->do_in_context(sub { ... })\*(R". The codeblock will be run, and
anything inside of it that looks for a context will find the one on which the
method was called.
.Sp
This \fB\s-1DOES NOT\s0\fR effect context on other hubs, only the hub used by the context
will be effected.
.Sp
.Vb 4
\&    my $ctx = ...;
\&    $ctx\->do_in_context(sub {
\&        my $ctx = context(); # returns the $ctx the sub is called on
\&    });
.Ve
.SS "\s-1EVENT PRODUCTION METHODS\s0"
.IX Subsection "EVENT PRODUCTION METHODS"
.ie n .IP "$event = $ctx\->ok($bool, $name)" 4
.el .IP "\f(CW$event\fR = \f(CW$ctx\fR\->ok($bool, \f(CW$name\fR)" 4
.IX Item "$event = $ctx->ok($bool, $name)"
.PD 0
.ie n .IP "$event = $ctx\->ok($bool, $name, \e@diag)" 4
.el .IP "\f(CW$event\fR = \f(CW$ctx\fR\->ok($bool, \f(CW$name\fR, \e@diag)" 4
.IX Item "$event = $ctx->ok($bool, $name, @diag)"
.PD
This will create an Test::Stream::Event::Ok object for you. The diagnostics
array will be used on the object in the event of a failure, if the test passes
the diagnostics will be ignored.
.ie n .IP "$event = $ctx\->note($message)" 4
.el .IP "\f(CW$event\fR = \f(CW$ctx\fR\->note($message)" 4
.IX Item "$event = $ctx->note($message)"
Send an Test::Stream::Event::Note. This event prints a message to \s-1STDOUT.\s0
.ie n .IP "$event = $ctx\->diag($message)" 4
.el .IP "\f(CW$event\fR = \f(CW$ctx\fR\->diag($message)" 4
.IX Item "$event = $ctx->diag($message)"
Send an Test::Stream::Event::Diag. This event prints a message to \s-1STDERR.\s0
.ie n .IP "$event = $ctx\->plan($max)" 4
.el .IP "\f(CW$event\fR = \f(CW$ctx\fR\->plan($max)" 4
.IX Item "$event = $ctx->plan($max)"
.PD 0
.ie n .IP "$event = $ctx\->plan(0, '\s-1SKIP\s0', $reason)" 4
.el .IP "\f(CW$event\fR = \f(CW$ctx\fR\->plan(0, '\s-1SKIP\s0', \f(CW$reason\fR)" 4
.IX Item "$event = $ctx->plan(0, 'SKIP', $reason)"
.PD
This can be used to send an Test::Stream::Event::Plan event. This event
usually takes either a number of tests you expect to run. Optionally you can
set the expected count to 0 and give the '\s-1SKIP\s0' directive with a reason to
cause all tests to be skipped.
.ie n .IP "$event = $ctx\->bail($reason)" 4
.el .IP "\f(CW$event\fR = \f(CW$ctx\fR\->bail($reason)" 4
.IX Item "$event = $ctx->bail($reason)"
This sends an Test::Stream::Event::Bail event. This event will completely
terminate all testing.
.ie n .IP "$event = $ctx\->send_event($Type, %parameters)" 4
.el .IP "\f(CW$event\fR = \f(CW$ctx\fR\->send_event($Type, \f(CW%parameters\fR)" 4
.IX Item "$event = $ctx->send_event($Type, %parameters)"
This lets you build and send an event of any type. The \f(CW$Type\fR argument should
be the event package name with \f(CW\*(C`Test::Stream::Event::\*(C'\fR left off, or a fully
qualified package name prefixed with a '+'. The event is returned after it is
sent.
.Sp
.Vb 1
\&    my $event = $ctx\->send_event(\*(AqOk\*(Aq, ...);
.Ve
.Sp
or
.Sp
.Vb 1
\&    my $event = $ctx\->send_event(\*(Aq+Test::Stream::Event::Ok\*(Aq, ...);
.Ve
.ie n .IP "$event = $ctx\->build_event($Type, %parameters)" 4
.el .IP "\f(CW$event\fR = \f(CW$ctx\fR\->build_event($Type, \f(CW%parameters\fR)" 4
.IX Item "$event = $ctx->build_event($Type, %parameters)"
This is the same as \f(CW\*(C`send_event()\*(C'\fR, except it builds and returns the event
without sending it.
.SH "HOOKS"
.IX Header "HOOKS"
There are 2 types of hooks, init hooks, and release hooks. As the names
suggest, these hooks are triggered when contexts are created or released.
.SS "\s-1INIT HOOKS\s0"
.IX Subsection "INIT HOOKS"
These are called whenever a context is initialized. That means when a new
instance is created. These hooks are \fB\s-1NOT\s0\fR called every time something
requests a context, just when a new one is created.
.PP
\fI\s-1GLOBAL\s0\fR
.IX Subsection "GLOBAL"
.PP
This is how you add a global init callback. Global callbacks happen for every
context for any hub or stack.
.PP
.Vb 4
\&    Test::Stream::Context\->ON_INIT(sub {
\&        my $ctx = shift;
\&        ...
\&    });
.Ve
.PP
\fI\s-1PER HUB\s0\fR
.IX Subsection "PER HUB"
.PP
This is how you add an init callback for all contexts created for a given hub.
These callbacks will not run for other hubs.
.PP
.Vb 4
\&    $hub\->add_context_init(sub {
\&        my $ctx = shift;
\&        ...
\&    });
.Ve
.PP
\fI\s-1PER CONTEXT\s0\fR
.IX Subsection "PER CONTEXT"
.PP
This is how you specify an init hook that will only run if your call to
\&\f(CW\*(C`context()\*(C'\fR generates a new context. The callback will be ignored if
\&\f(CW\*(C`context()\*(C'\fR is returning an existing context.
.PP
.Vb 4
\&    my $ctx = context(on_init => sub {
\&        my $ctx = shift;
\&        ...
\&    });
.Ve
.SS "\s-1RELEASE HOOKS\s0"
.IX Subsection "RELEASE HOOKS"
These are called whenever a context is released. That means when the last
reference to the instance is about to be destroyed. These hooks are \fB\s-1NOT\s0\fR
called every time \f(CW\*(C`$ctx\->release\*(C'\fR is called.
.PP
\fI\s-1GLOBAL\s0\fR
.IX Subsection "GLOBAL"
.PP
This is how you add a global release callback. Global callbacks happen for every
context for any hub or stack.
.PP
.Vb 4
\&    Test::Stream::Context\->ON_RELEASE(sub {
\&        my $ctx = shift;
\&        ...
\&    });
.Ve
.PP
\fI\s-1PER HUB\s0\fR
.IX Subsection "PER HUB"
.PP
This is how you add a release callback for all contexts created for a given
hub. These callbacks will not run for other hubs.
.PP
.Vb 4
\&    $hub\->add_context_release(sub {
\&        my $ctx = shift;
\&        ...
\&    });
.Ve
.PP
\fI\s-1PER CONTEXT\s0\fR
.IX Subsection "PER CONTEXT"
.PP
This is how you add release callbacks directly to a context. The callback will
\&\fB\s-1ALWAYS\s0\fR be added to the context that gets returned, it does not matter if a
new one is generated, or if an existing one is returned.
.PP
.Vb 4
\&    my $ctx = context(on_release => sub {
\&        my $ctx = shift;
\&        ...
\&    });
.Ve
.SH "SOURCE"
.IX Header "SOURCE"
The source code repository for Test::Stream can be found at
\&\fIhttp://github.com/Test\-More/Test\-Stream/\fR.
.SH "MAINTAINERS"
.IX Header "MAINTAINERS"
.IP "Chad Granum <exodist@cpan.org>" 4
.IX Item "Chad Granum <exodist@cpan.org>"
.SH "AUTHORS"
.IX Header "AUTHORS"
.PD 0
.IP "Chad Granum <exodist@cpan.org>" 4
.IX Item "Chad Granum <exodist@cpan.org>"
.IP "Kent Fredric <kentnl@cpan.org>" 4
.IX Item "Kent Fredric <kentnl@cpan.org>"
.PD
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2015 Chad Granum <exodist7@gmail.com>.
.PP
This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
.PP
See \fIhttp://www.perl.com/perl/misc/Artistic.html\fR
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 491:" 4
.IX Item "Around line 491:"
Unterminated C<...> sequence
