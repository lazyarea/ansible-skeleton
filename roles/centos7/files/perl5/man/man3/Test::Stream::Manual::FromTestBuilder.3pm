.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Test::Stream::Manual::FromTestBuilder 3"
.TH Test::Stream::Manual::FromTestBuilder 3 "2015-10-13" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Test::Stream::Manual::FromTestBuilder \- Translation document for people moving
from Test::More, Test::Simple, or other Test::Builder tools.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This document covers things that are meaningful to someone switching from
Test::More, Test::Simple, and other Test::Builder based tools. It
approaches the situation as though you are converting an old test, or writing a
new one. Instead of loading Test::More you will be loading Test::Stream
with the recommended bundle:
.PP
.Vb 1
\&    use Test::Stream \-V1;
\&
\&    ...
.Ve
.SH "WHAT IS (MOSTLY) THE SAME?"
.IX Header "WHAT IS (MOSTLY) THE SAME?"
This is the list of stuff that has either not changed, or changed only in ways
not likely to be noticed.
.SS "\s-1FUNCTIONS\s0"
.IX Subsection "FUNCTIONS"
.IP "ok" 4
.IX Item "ok"
The signature is different, instead of \f(CW\*(C`ok($$;$)\*(C'\fR it is now \f(CW\*(C`ok($$;$@)\*(C'\fR. The
slurpy \f(CW\*(C`@\*(C'\fR allows you to add diagnostics messages that will only be shown if
the test fails. This allows you to attach custom diagnostics directly to a
failing test.
.Sp
Defined in Test::Stream::Plugin::Core.
.IP "diag" 4
.IX Item "diag"
No differences
.Sp
Defined in Test::Stream::Plugin::Core.
.IP "note" 4
.IX Item "note"
No differences
.Sp
Defined in Test::Stream::Plugin::Core.
.IP "pass" 4
.IX Item "pass"
No differences
.Sp
Defined in Test::Stream::Plugin::Core.
.IP "fail" 4
.IX Item "fail"
Signature changed from \f(CWfail($)\fR to \f(CW\*(C`fail($;@)\*(C'\fR. Extra arguments are
diagnostics that will be shown with your failing test.
.Sp
Defined in Test::Stream::Plugin::Core.
.IP "done_testing" 4
.IX Item "done_testing"
No longer accepts arguments. Most people did not know it could accept arguments
in Test::More so it is unlikely to effect many people.
.Sp
Defined in Test::Stream::Plugin::Core.
.IP "\s-1BAIL_OUT\s0" 4
.IX Item "BAIL_OUT"
No differences
.Sp
Defined in Test::Stream::Plugin::Core.
.IP "skip" 4
.IX Item "skip"
No differences
.Sp
Defined in Test::Stream::Plugin::Core.
.IP "can_ok" 4
.IX Item "can_ok"
No differences
.Sp
Defined in Test::Stream::Plugin::Core.
.SS "\s-1BEHAVIOR\s0"
.IX Subsection "BEHAVIOR"
.IP "\s-1TAP\s0 is still the default output format." 4
.IX Item "TAP is still the default output format."
.PD 0
.IP "You get similar if not identical diagnostics at the end of a failing test file." 4
.IX Item "You get similar if not identical diagnostics at the end of a failing test file."
.IP "You get file and line number for failed tests." 4
.IX Item "You get file and line number for failed tests."
.PD
.SH "WHAT IS (SIGNIFICANTLY) DIFFERENT?"
.IX Header "WHAT IS (SIGNIFICANTLY) DIFFERENT?"
This is a list of very notable changes that are likely to hurt you if you are
not aware of them.
.SS "\s-1FUNCTIONS\s0"
.IX Subsection "FUNCTIONS"
.IP "is" 4
.IX Item "is"
.PD 0
.IP "is_deeply" 4
.IX Item "is_deeply"
.PD
\&\f(CW\*(C`is\*(C'\fR and \f(CW\*(C`is_deeply\*(C'\fR have been combined. You can now use \f(CW\*(C`is\*(C'\fR for simple
scalars, or nested data structures. This also means you can no longer use \f(CW\*(C`is\*(C'\fR
to check that hash/array reference are the same exact reference, though you can
check that they have the exact same data. If you actually want to check if 2
hash/array refs are the same or different you can use \f(CW\*(C`ref_is()\*(C'\fR or
\&\f(CW\*(C`ref_is_not()\*(C'\fR, both of which are much safer for that purpose than \f(CW\*(C`is()\*(C'\fR
ever was.
.Sp
The signature has also been changed to add a slurpy '@' to the end for
specifying extra diagnostics that only show up if the test fails.
.Sp
The diagnostics have also been improved so that a table is shown with all the
differences (default cap of 25 differences, this can be altered with the
\&\s-1TS_MAX_DELTA\s0 environment variable).
.Sp
Here is an example of a failing test:
.Sp
.Vb 5
\&    is(
\&        { a => 1, b => 2, c => [ \*(Aqa\*(Aq, \*(Aqb\*(Aq, \*(Aqc\*(Aq ]},
\&        { a => 2, b => 3, c => [ \*(Aqx\*(Aq, \*(Aqy\*(Aq, \*(Aqz\*(Aq ]},
\&        "These are clearly different"
\&    );
.Ve
.Sp
It produces:
.Sp
.Vb 12
\&    not ok 1 \- These are clearly different
\&    # Failed test \*(AqThese are clearly different\*(Aq
\&    # at test.pl line 3.
\&    # +\-\-\-\-\-\-\-\-+\-\-\-\-\-+\-\-\-\-+\-\-\-\-\-\-\-+
\&    # | PATH   | GOT | OP | CHECK |
\&    # +\-\-\-\-\-\-\-\-+\-\-\-\-\-+\-\-\-\-+\-\-\-\-\-\-\-+
\&    # | {a}    | 1   | == | 2     |
\&    # | {b}    | 2   | == | 3     |
\&    # | {c}[0] | a   | eq | x     |
\&    # | {c}[1] | b   | eq | y     |
\&    # | {c}[2] | c   | eq | z     |
\&    # +\-\-\-\-\-\-\-\-+\-\-\-\-\-+\-\-\-\-+\-\-\-\-\-\-\-+
.Ve
.Sp
Notice that it gives you all the differences. It tells you the path of each
difference within the structure, what it got, and what it was checking against.
It also tells you what operator it used for the comparison, that way you will
know if the problem is the comparison used rather than the values checked.
.Sp
The final column is called '\s-1CHECK\s0' because there are extra tools provided by
Test::Stream::Plugin::Compare that give you more control over how to compare
values and structures, '\s-1EXPECTED\s0' does not work as a heading.
.Sp
The table is smart about your screen size and formatting values displayed
within. All whitespace apart from the \s-1ASCII\s0 single space is replaced with
either its escape sequence, or its unicode number. If there is trailing
whitespace the final whitespace character will also be replaced to make it
clear to you it is there.
.Sp
\&\fBDefined in\fR Test::Stream::Plugin::Compare.
.IP "like" 4
.IX Item "like"
\&\f(CW\*(C`like\*(C'\fR still works like it did before, \f(CW\*(C`like($var, qr/.../)\*(C'\fR will not need to
be changed. However it has been changed much like \f(CW\*(C`is()\*(C'\fR in that it can be
used to check deep data structures. However \f(CW\*(C`like\*(C'\fR is not as strict as \f(CW\*(C`is\*(C'\fR,
and only checks for things you specify. In addition regexes and coderefs
appearing in the second structure are used as checks rather than exact
comparisons:
.Sp
.Vb 10
\&    like(
\&        { a => \*(Aqaaa\*(Aq, b => \*(Aqbbb\*(Aq, c => [\*(Aqa\*(Aq .. \*(Aqz\*(Aq], d => \*(Aqddd\*(Aq },
\&        {
\&            a => qr/a/,                  # regex is used to check the value
\&            b => sub { $_ eq \*(Aqbbb\*(Aq },    # Code is run to check result
\&            c => [ \*(Aqa\*(Aq, \*(Aqb\*(Aq, \*(Aqc\*(Aq ],      # Only the first 3 items are checked
\&            # hash key \*(Aqd\*(Aq is ignored since we did not specify it
\&        },
\&        "Parts of the structure we care about match"
\&    );
.Ve
.Sp
\&\fBDefined in\fR Test::Stream::Plugin::Compare.
.IP "plan" 4
.IX Item "plan"
Only accepts a number of test expected to be run.
.Sp
.Vb 1
\&    plan 5;
.Ve
.Sp
See \f(CW\*(C`skip_all\*(C'\fR for skipping an entire test.
.Sp
\&\fBDefined in\fR Test::Stream::Plugin::Core.
.IP "skip_all" 4
.IX Item "skip_all"
This is the new way to skip an entire test, it takes a reason as its argument.
.Sp
.Vb 1
\&    skip_all \*(AqBroken for now\*(Aq;
.Ve
.Sp
\&\fBDefined in\fR Test::Stream::Plugin::Core.
.IP "isa_ok" 4
.IX Item "isa_ok"
It was common for people to use this incorrectly in Test::More. It was
reasonable to assume it worked like \f(CW\*(C`can_ok\*(C'\fR and accepted several package
names. Instead the Test::More implementation used the third argument as an
alternate name for the first. This has been changed to be consistent with
\&\f(CW\*(C`can_ok\*(C'\fR and similar tools.
.Sp
.Vb 1
\&    isa_ok($thing, \*(AqMy::Class\*(Aq, \*(AqMy::Subclass\*(Aq, ...);
.Ve
.Sp
\&\fBDefined in\fR Test::Stream::Plugin::Core.
.IP "subtest" 4
.IX Item "subtest"
Not loaded by default, you must ask for it:
.Sp
.Vb 1
\&    use Test::Stream qw/\-V1 Subtest/;
.Ve
.Sp
The default output has been changed:
.Sp
.Vb 5
\&    ok 1 \- Subtest Name {
\&        ok 1 \- subtest result
\&        ok 2 \- another result
\&        1..2
\&    # }
.Ve
.Sp
The old output format can be used if requested:
.Sp
.Vb 1
\&    use Test::Stream \*(Aq\-V1\*(Aq, \*(AqSubtest\*(Aq => [\*(Aqstreamed\*(Aq];
.Ve
.Sp
Defined in Test::Stream::Plugin::Subtest.
.SH "WHAT IS COMPLETELY GONE?"
.IX Header "WHAT IS COMPLETELY GONE?"
These are no longer around for you to use.
.SS "\s-1FUNCTIONS\s0"
.IX Subsection "FUNCTIONS"
.IP "use_ok" 4
.IX Item "use_ok"
.PD 0
.IP "require_ok" 4
.IX Item "require_ok"
.PD
Errors loading modules cause the test to die anyway, so just load them, if they
do not work the test will fail. Making a seperate \s-1API\s0 for this is a wasted
effort. Also doing this requires the functions to guess if you provided a
module name, or filename, and then munging the input to figure out what
actually needs to be loaded.
.IP "new_ok" 4
.IX Item "new_ok"
This is easy enough:
.Sp
.Vb 1
\&    ok(my $one = $class\->new(@args), "NAME");
.Ve
.Sp
The utility of \f(CW\*(C`new_ok()\*(C'\fR is questionable at best.
.IP "eq_array" 4
.IX Item "eq_array"
.PD 0
.IP "eq_hash" 4
.IX Item "eq_hash"
.IP "eq_set" 4
.IX Item "eq_set"
.PD
Test::More itself discourages you from using these, so we are not carrying
them forward.
.IP "explain" 4
.IX Item "explain"
This method was copied in an API-incompatible way from Test::Most. This
created an incompatability issue between the 2 libraries and made a real mess
of things. There is value in a tool like this, but if it is added it will be
added with a new name to avoid conflicts.
.IP "cmp_ok" 4
.IX Item "cmp_ok"
It is easy to write:
.Sp
.Vb 1
\&    ok($got == $want, "$got == $want");
.Ve
.Sp
cmp_eq did not buy very much more. There were added diagnostics, and they were
indeed valuable. The issue is that the implementation for a cmp_ok that accepts
arbitrary comparison operators is \s-1VERY\s0 complex. Further there are a great many
edge cases to account for. Warnings that have to do with uninitialized or
improper arguments to the operators also report to internals if not handled
properly.
.Sp
All these issues are solvable, but they lead to very complex, slow, and easily
broken code. I have fixed bugs in the old cmp_ok implementation, and can tell
you it is a mess. I have also written no less than 3 replacements for cmp_ok,
all of which proved complex enough that I do not feel it is worth maintaining
in Test::Stream core.
.Sp
If you want cmp_ok badly enough you can write a plugin for it.
.SS "\s-1VARIABLES\s0"
.IX Subsection "VARIABLES"
.ie n .IP "$TODO" 4
.el .IP "\f(CW$TODO\fR" 4
.IX Item "$TODO"
The \f(CW$TODO\fR variable is completely gone. Do not use it. Instead we have the
\&\f(CW\*(C`todo()\*(C'\fR function. There are 2 ways to use the todo function:
.Sp
Similar to old way:
.Sp
.Vb 5
\&    TODO: {
\&        # Note, this is a lexical variable, not a package variable. Do not use
\&        # local. The todo will end when the variable is destroyed (at the end
\&        # of the scope, or when you assign it to undef.
\&        my $todo = todo "These are not ready yet";
\&
\&        ok(0, \*(Aqtodo\*(Aq);
\&    }
.Ve
.Sp
Another way:
.Sp
.Vb 3
\&    todo \*(AqThese are not ready yet\*(Aq => sub {
\&        ok(0, \*(Aqtodo\*(Aq);
\&    };
.Ve
.ie n .IP "$Test::Builder::Level" 4
.el .IP "\f(CW$Test::Builder::Level\fR" 4
.IX Item "$Test::Builder::Level"
See Test::Stream::Context for how <Test:Stream> solves the same problem.
.SS "\s-1BEHAVIOR\s0"
.IX Subsection "BEHAVIOR"
.IP "plan at import" 4
.IX Item "plan at import"
\&\f(CW\*(C`done_testing\*(C'\fR is the preferred way to plan. However if you really want a plan
you can use the \f(CW\*(C`plan()\*(C'\fR or \f(CW\*(C`skip_all\*(C'\fR functions. Setting the plan at compile
time resulted in bugs in the past (primarily with subtests that loaded external
files), moving away from that \s-1API\s0 shortcut helps to make things cleaner.
.SH "WHAT ELSE DO I GET?"
.IX Header "WHAT ELSE DO I GET?"
This is some new stuff you get for free!
.SS "\s-1FUNCTIONS\s0"
.IX Subsection "FUNCTIONS"
.IP "DOES_ok" 4
.IX Item "DOES_ok"
Just like \f(CW\*(C`isa_ok\*(C'\fR and \f(CW\*(C`can_ok\*(C'\fR except it checks \f(CW\*(C`DOES\*(C'\fR instead of \f(CW\*(C`can\*(C'\fR or
\&\f(CW\*(C`isa\*(C'\fR. All caps is used to reflect the \s-1UNIVERSAL\s0 property used, it also helps
avoid conflicts with Moose related stuff.
.Sp
\&\fBDefined in\fR Test::Stream::Plugin::Core.
.IP "ref_ok" 4
.IX Item "ref_ok"
Check that something is a ref, and optionally that it is a specific type of
ref.
.Sp
\&\fBDefined in\fR Test::Stream::Plugin::Core.
.IP "imported_ok" 4
.IX Item "imported_ok"
Check that the current namespace has the specified functions. This will not
find inherited methods, only subs actually defined in the current namespace. It
will \fB\s-1NOT\s0\fR check that the subs came from another package.
.Sp
This is a better alternative to \f(CW\*(C`can_ok\*(C'\fR when testing imports.
.Sp
\&\fBDefined in\fR Test::Stream::Plugin::Core.
.IP "not_imported_ok" 4
.IX Item "not_imported_ok"
This checks that the specified functions are not available in the current
namespace. It will ignore inherited methods, is only looks for subs in the
current namespace.
.Sp
\&\fBDefined in\fR Test::Stream::Plugin::Core.
.IP "ref_is" 4
.IX Item "ref_is"
Check that 2 references are the same references, not a deep check, compares
addresses of the 2 provided refs. Will fail if either argument is not a
reference, or is undef.
.Sp
\&\fBDefined in\fR Test::Stream::Plugin::Core.
.IP "ref_is_not" 4
.IX Item "ref_is_not"
Check that 2 references are not the same references, not a deep check, compares
addresses of the 2 provided refs. Will fail if either argument is not a
reference, or is undef.
.Sp
\&\fBDefined in\fR Test::Stream::Plugin::Core.
.IP "set_encoding" 4
.IX Item "set_encoding"
Can be used to set the encoding of \s-1TAP,\s0 and possibly other formatters.
.Sp
.Vb 2
\&    use Test::Stream \-V1;
\&    use utf8;
\&
\&    set_encoding \*(Aqutf8\*(Aq;
\&    # No wide character warnings
\&    ok(1, \*(AqX\*(Aq);
.Ve
.Sp
\&\fBDefined in\fR Test::Stream::Plugin::Core.
.IP "context" 4
.IX Item "context"
This is the alternative to \f(CW$Test::Builder::Level\fR. See
Test::Stream::Context for more info.
.Sp
\&\fBDefined in\fR Test::Stream::Plugin::Context.
.IP "mock" 4
.IX Item "mock"
This is a 1\-stop shop for all your mocking needs. Mock classes, instances, etc.
This is the next generation of mocking after Mock::Quick and borrows the
good ideas from it. See the Mock plugin for more details, or for access to the
capabilities using multiple functions instead of a single monolithic one.
.Sp
\&\fBDefined in\fR Test::Stream::Plugin::Mock.
.IP "mocked" 4
.IX Item "mocked"
Used to check if something has been mocked using the Mock plugin.
.Sp
\&\fBDefined in\fR Test::Stream::Plugin::Mock.
.IP "warning { ... }" 4
.IX Item "warning { ... }"
Run the code and return the warning it is expected to produce. Dies if it gets
too many warnings, or too few.
.Sp
\&\fBDefined in\fR Test::Stream::Plugin::Warnings.
.IP "warns { ... }" 4
.IX Item "warns { ... }"
Returns an arrayref of all the warnings from within the codeblock, undef if
there are no warnings.
.Sp
.Vb 1
\&    ok(!warns { ... }, "no warnings");
\&
\&    like(
\&        warns { ... },
\&        [
\&            qr/xxx/,
\&            qr/yyy/,
\&        ],
\&        "Got both expected warnings",
\&    );
.Ve
.Sp
\&\fBDefined in\fR Test::Stream::Plugin::Warnings.
.IP "no_warnings { ... }" 4
.IX Item "no_warnings { ... }"
Returns false if the block produces warnings, true if there are none. This will
also display the warnings if any occur.
.Sp
.Vb 1
\&    ok(no_warnings { ... }, "got no warnings");
.Ve
.Sp
\&\fBDefined in\fR Test::Stream::Plugin::Warnings.
.IP "lives { ... }" 4
.IX Item "lives { ... }"
Returns true if the block does not throw any exceptions. Returns false and
displays the exception as a warning if the block does die.
.Sp
.Vb 1
\&    ok(lives { ... }, "did not die");
.Ve
.Sp
\&\fBDefined in\fR Test::Stream::Plugin::Exception.
.IP "dies { ... }" 4
.IX Item "dies { ... }"
Returns the exception produced by the block, or undef if it did not die.
.Sp
.Vb 5
\&    like(
\&        dies { ... },
\&        qr/xxx/,
\&        "Got excpetion"
\&    );
.Ve
.Sp
\&\fBDefined in\fR Test::Stream::Plugin::Exception.
.SS "\s-1BEHAVIOR\s0"
.IX Subsection "BEHAVIOR"
.IP "Forking/Threading support" 4
.IX Item "Forking/Threading support"
Forking and threading in your tests will just work (so long as you use the
\&'\s-1IPC\s0' plugin, which is included in the 'V1' bundle).
.SH "SOURCE"
.IX Header "SOURCE"
The source code repository for Test::Stream can be found at
\&\fIhttp://github.com/Test\-More/Test\-Stream/\fR.
.SH "MAINTAINERS"
.IX Header "MAINTAINERS"
.IP "Chad Granum <exodist@cpan.org>" 4
.IX Item "Chad Granum <exodist@cpan.org>"
.SH "AUTHORS"
.IX Header "AUTHORS"
.PD 0
.IP "Chad Granum <exodist@cpan.org>" 4
.IX Item "Chad Granum <exodist@cpan.org>"
.PD
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2015 Chad Granum <exodist7@gmail.com>.
.PP
This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
.PP
See \fIhttp://www.perl.com/perl/misc/Artistic.html\fR
