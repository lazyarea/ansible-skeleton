.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Test::Stream::Workflow 3"
.TH Test::Stream::Workflow 3 "2015-10-13" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Test::Stream::Workflow \- Interface for writing 'workflow' tools such as RSPEC
implementations that all play nicely together.
.SH "EXPERIMENTAL CODE WARNING"
.IX Header "EXPERIMENTAL CODE WARNING"
\&\fBThis is an experimental release!\fR Test-Stream, and all its components are
still in an experimental phase. This dist has been released to cpan in order to
allow testers and early adopters the chance to write experimental new tools
with it, or to add experimental support for it into old tools.
.PP
\&\fB\s-1PLEASE DO NOT COMPLETELY CONVERT OLD TOOLS YET\s0\fR. This experimental release is
very likely to see a lot of code churn. \s-1API\s0's may break at any time.
Test-Stream should \s-1NOT\s0 be depended on by any toolchain level tools until the
experimental phase is over.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module intends to do for 'workflow' test tools what Test::Builder and
Test::Stream do for general test tools. The problem with workflow tools is that
most do not play well together. This module is a very generic/abstract look at
workflows that allows tools to be built that accomplish their workflows, but in
a way that plays well with others.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    package My::Workflow::Tool;
\&    use Test::Stream::Workflow qw/gen_unit_builder/;
\&
\&    use Test::Stream::Exporter;
\&
\&    # Create a wrapping tool
\&    export my_wrapper => gen_unit_builder(\*(Aqsimple\*(Aq => qw/buildup teardown/);
\&
\&    no Test::Stream::Exporter;
.Ve
.PP
To use it:
.PP
.Vb 1
\&    use My::Workflow::Tool qw/my_wrapper/;
\&
\&    my_wrapper foo => sub {
\&        my $inner = shift;
\&        ...
\&        $inner\->();
\&        ...
\&    };
.Ve
.SH "IMPORTANT CONCEPTS"
.IX Header "IMPORTANT CONCEPTS"
A workflow is a way of defining tests with scaffolding. Essentially you are
seperating your assertions and your setup/teardown/management code. This
results in a separation of concerns that can produce more maintainable tests.
In addition each component of a workflow can be re-usable and/or inheritable.
.SS "\s-1UNITS\s0"
.IX Subsection "UNITS"
Units are the small composable parts of a workflow. You can think of a unit as
a named function that does some work. What separates a unit from a regular
function is that it can have other units attashed to it in various ways. A unit
can also be a 'group' unit, which means it contains other units as its primary
work.
.PP
See Test::Stream::Workflow::Unit.
.SS "\s-1PACKAGE UNIT\s0"
.IX Subsection "PACKAGE UNIT"
The package unit is the root 'group' unit for your test package. All other test
units get put into the main package unit.
.PP
See Test::Stream::Workflow::Meta where the primary unit is stored.
.SS "\s-1BUILDS\s0"
.IX Subsection "BUILDS"
Units are generally defined using a \s-1DSL \s0(Domain Specific Language). In this \s-1DSL\s0
you declare a unit, which gets added as the current build, then run code which
modifies that build to turn it into the unit you need.
.SS "\s-1BUILD STACK\s0"
.IX Subsection "BUILD STACK"
Builds can be defined within one another, as such the 'current' build is
whatever build is on top of the build stack, which is a private array. There
are low level functions exposed to give you control over the stack if you need
it, but in general you should use a higher level tool.
.SS "\s-1TASK\s0"
.IX Subsection "TASK"
A task is a composition of units to be run. The runner will compile you units
into task form, then run the compiled tasks.
.SS "\s-1VAR STASH\s0"
.IX Subsection "VAR STASH"
There is a var stash. The var stash is a stack of hashes. Every time a task is
run a new hash is pushed onto the stack. When a task is complete the hash is
popped and cleared. Workflow tools may use this hash to store/define variables
that will go away when the current task is complete.
.SH "EXPORTS"
.IX Header "EXPORTS"
All exports are optional, you must request the ones you want.
.SS "\s-1BUILD STACK\s0"
.IX Subsection "BUILD STACK"
.ie n .IP "$unit = \fIworkflow_build()\fR" 4
.el .IP "\f(CW$unit\fR = \fIworkflow_build()\fR" 4
.IX Item "$unit = workflow_build()"
Get the unit at the top of the build stack, if any.
.ie n .IP "$unit = \fIworkflow_current()\fR" 4
.el .IP "\f(CW$unit\fR = \fIworkflow_current()\fR" 4
.IX Item "$unit = workflow_current()"
Get the unit at the top of the build stack, if there is none then return the
root unit for the package the function is called from.
.IP "push_workflow_build($unit)" 4
.IX Item "push_workflow_build($unit)"
Push a unit onto the build stack.
.IP "pop_workflow_build($unit)" 4
.IX Item "pop_workflow_build($unit)"
Pop a unit from the build stack. You must provide the \f(CW$unit\fR you expect to
pop, and it must match the one at the top of the stack.
.SS "\s-1VAR STASH\s0"
.IX Subsection "VAR STASH"
.ie n .IP "$val = workflow_var($name)" 4
.el .IP "\f(CW$val\fR = workflow_var($name)" 4
.IX Item "$val = workflow_var($name)"
.PD 0
.ie n .IP "$val = workflow_var($name, $val)" 4
.el .IP "\f(CW$val\fR = workflow_var($name, \f(CW$val\fR)" 4
.IX Item "$val = workflow_var($name, $val)"
.ie n .IP "$val = workflow_var($name, \e&default)" 4
.el .IP "\f(CW$val\fR = workflow_var($name, \e&default)" 4
.IX Item "$val = workflow_var($name, &default)"
.PD
This function will get/set a variable in the var stash. If only a name is
provided then it will return the current value, or undef. If you provide a
value as the second argument then the value will be set.
.Sp
A coderef can be passed in as the second argument. If a coderef is used it will
be considered a default generator. If the variable name already has a value
then that value will be kept and returned. If the variable has not been set
then the coderef will be run and the value it returns will be stored and
returned.
.ie n .IP "$hr = \fIpush_workflow_vars()\fR" 4
.el .IP "\f(CW$hr\fR = \fIpush_workflow_vars()\fR" 4
.IX Item "$hr = push_workflow_vars()"
.PD 0
.IP "push_workflow_vars($hr)" 4
.IX Item "push_workflow_vars($hr)"
.PD
You can manually push a new hashref to the top of the vars stack. If you do
this you need to be sure to pop it before anything else tries to pop any hash
below yours in the stack. You can provide a hashref to push, or it will create
a new one for you.
.IP "pop_workflow_vars($hr)" 4
.IX Item "pop_workflow_vars($hr)"
This will let you manually pop the workflow vars stack. You must provide a
reference to the item you think is at the top of the stack (the one you want to
pop). If something else is on top of the stack then an exception will be
thrown.
.ie n .IP "$bool = \fIhas_workflow_vars()\fR" 4
.el .IP "\f(CW$bool\fR = \fIhas_workflow_vars()\fR" 4
.IX Item "$bool = has_workflow_vars()"
Check if there is a workflow vars hash on the stack. This will return false if
there is nothing on the stack. Currently this returns the number of items in
the stack, but that may change so do not depend on that behavior.
.SS "\s-1META DATA\s0"
.IX Subsection "META DATA"
.ie n .IP "$meta = \fIworkflow_meta()\fR" 4
.el .IP "\f(CW$meta\fR = \fIworkflow_meta()\fR" 4
.IX Item "$meta = workflow_meta()"
Get the Test::Stream::Workflow::Meta object associated with the current
package.
.IP "workflow_runner($runner)" 4
.IX Item "workflow_runner($runner)"
Set the runner to use. The runner can be a package name, or a blessed object.
Whichever you provide, it must have a 'run' method. The run method will be
called directly on what you provide, that is if you provide a package name then
it will call \f(CW\*(C`$package\->run()\*(C'\fR \f(CW\*(C`new()\*(C'\fR will not be called for you.
.IP "workflow_runner_args(\e@args)" 4
.IX Item "workflow_runner_args(@args)"
Arguments that should be passed to the \f(CW\*(C`run()\*(C'\fR method of your runner.
.IP "\fIworkflow_run()\fR" 4
.IX Item "workflow_run()"
Run the workflow now.
.SS "\s-1CREATING UNITS\s0"
.IX Subsection "CREATING UNITS"
.ie n .IP "$unit = group_builder($name, \e%params, sub { ... })" 4
.el .IP "\f(CW$unit\fR = group_builder($name, \e%params, sub { ... })" 4
.IX Item "$unit = group_builder($name, %params, sub { ... })"
.PD 0
.ie n .IP "$unit = group_builder($name, sub { ... })" 4
.el .IP "\f(CW$unit\fR = group_builder($name, sub { ... })" 4
.IX Item "$unit = group_builder($name, sub { ... })"
.IP "group_builder($name, \e%params, sub { ... })" 4
.IX Item "group_builder($name, %params, sub { ... })"
.IP "group_builder($name, sub { ... })" 4
.IX Item "group_builder($name, sub { ... })"
.PD
The group builder will create a new unit with the given name and parameters.
The new unit will be placed onto the build stack, and the code reference you
provide will be run. Once the code reference returns the unit will be removed
from the build stack. If called in void context the unit will be added to the
next unit on the build stack, or to the package root unit. If called in any
other context the unit will be returned.
.ie n .IP "$sub = gen_unit_builder($callback, @stashes)" 4
.el .IP "\f(CW$sub\fR = gen_unit_builder($callback, \f(CW@stashes\fR)" 4
.IX Item "$sub = gen_unit_builder($callback, @stashes)"
This will return a coderef that accepts the typical \f(CW$name\fR, optional
\&\f(CW\*(C`\e%params\*(C'\fR, and \f(CW\*(C`\e&code\*(C'\fR arguments. The code returned will construct your
unit for you, and then insert it into the specified stashes of the current
build whenever it is called. Typically you will only specify one stash, but you
may combine \f(CW\*(C`buildup\*(C'\fR and \f(CW\*(C`teardown\*(C'\fR if the builder you are creating is
supposed to wrap other units.
.Sp
\&\fBStashes:\fR
.RS 4
.IP "primary" 4
.IX Item "primary"
A primary action.
.IP "modify" 4
.IX Item "modify"
Something to modify the primary actions.
.IP "buildup" 4
.IX Item "buildup"
Something to run before the primary actions.
.IP "teardown" 4
.IX Item "teardown"
Something to run after the primary actions.
.RE
.RS 4
.RE
.ie n .IP "($unit, $code, $caller) = new_proto_unit(\e%params)" 4
.el .IP "($unit, \f(CW$code\fR, \f(CW$caller\fR) = new_proto_unit(\e%params)" 4
.IX Item "($unit, $code, $caller) = new_proto_unit(%params)"
.RS 4
.PD 0
.IP "level => 1" 4
.IX Item "level => 1"
.IP "caller => [caller($level)]" 4
.IX Item "caller => [caller($level)]"
.IP "args => [$name, \e%params, \e&code]" 4
.IX Item "args => [$name, %params, &code]"
.IP "args => [$name, \e&code]" 4
.IX Item "args => [$name, &code]"
.ie n .IP "set_primary => $bool" 4
.el .IP "set_primary => \f(CW$bool\fR" 4
.IX Item "set_primary => $bool"
.IP "unit => \e%attributes" 4
.IX Item "unit => %attributes"
.PD
This is used under the hood by \f(CW\*(C`gen_unit_builder()\*(C'\fR. This will parse the 2 or
3 typical input arguments, verify them, and return a new
Test::Stream::Workflow::Unit, the coderef that was passed in, and a caller
arrayref.
.Sp
If you use this it is your job to put the unit where it should be. Normally
\&\f(CW\*(C`gen_unit_builder\*(C'\fR and \f(CW\*(C`group_builder\*(C'\fR are all you should need.
.RE
.RS 4
.RE
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "Test::Stream::Plugin::Spec" 4
.IX Item "Test::Stream::Plugin::Spec"
Test::Stream::Plugin::Spec is an implementation of \s-1RSPEC\s0 using this library.
.SH "SOURCE"
.IX Header "SOURCE"
The source code repository for Test::Stream can be found at
\&\fIhttp://github.com/Test\-More/Test\-Stream/\fR.
.SH "MAINTAINERS"
.IX Header "MAINTAINERS"
.IP "Chad Granum <exodist@cpan.org>" 4
.IX Item "Chad Granum <exodist@cpan.org>"
.SH "AUTHORS"
.IX Header "AUTHORS"
.PD 0
.IP "Chad Granum <exodist@cpan.org>" 4
.IX Item "Chad Granum <exodist@cpan.org>"
.PD
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2015 Chad Granum <exodist7@gmail.com>.
.PP
This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
.PP
See \fIhttp://www.perl.com/perl/misc/Artistic.html\fR
