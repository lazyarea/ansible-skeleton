.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Test::Stream::Util 3"
.TH Test::Stream::Util 3 "2015-10-13" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Test::Stream::Util \- Tools used by Test::Stream and friends.
.SH "EXPERIMENTAL CODE WARNING"
.IX Header "EXPERIMENTAL CODE WARNING"
\&\fBThis is an experimental release!\fR Test-Stream, and all its components are
still in an experimental phase. This dist has been released to cpan in order to
allow testers and early adopters the chance to write experimental new tools
with it, or to add experimental support for it into old tools.
.PP
\&\fB\s-1PLEASE DO NOT COMPLETELY CONVERT OLD TOOLS YET\s0\fR. This experimental release is
very likely to see a lot of code churn. \s-1API\s0's may break at any time.
Test-Stream should \s-1NOT\s0 be depended on by any toolchain level tools until the
experimental phase is over.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Collection of tools used by Test::Stream and friends.
.SH "EXPORTS"
.IX Header "EXPORTS"
All exports are optional, you must specify subs to import. If you want to
import everything use '\-all'.
.PP
.Vb 1
\&    use Test::Stream::Util \*(Aq\-all\*(Aq;
.Ve
.ie n .IP "($success, $error) = try { ... }" 4
.el .IP "($success, \f(CW$error\fR) = try { ... }" 4
.IX Item "($success, $error) = try { ... }"
Eval the codeblock, return success or failure, and the error message. This code
protects $@ and $!, they will be restored by the end of the run. This code also
temporarily blocks \f(CW$SIG\fR{\s-1DIE\s0} handlers.
.IP "protect { ... }" 4
.IX Item "protect { ... }"
Similar to try, except that it does not catch exceptions. The idea here is to
protect $@ and $! from changes. $@ and $! will be restored to whatever they
were before the run so long as it is successful. If the run fails $! will still
be restored, but $@ will contain the exception being thrown.
.IP "\s-1USE_THREADS\s0" 4
.IX Item "USE_THREADS"
Returns true if threads are enabled, false if they are not.
.IP "get_tid" 4
.IX Item "get_tid"
This will return the id of the current thread when threads are enabled,
otherwise it returns 0.
.ie n .IP "my $file = pkg_to_file($package)" 4
.el .IP "my \f(CW$file\fR = pkg_to_file($package)" 4
.IX Item "my $file = pkg_to_file($package)"
Convert a package name to a filename.
.ie n .IP "$stash = get_stash($package)" 4
.el .IP "\f(CW$stash\fR = get_stash($package)" 4
.IX Item "$stash = get_stash($package)"
Returns the stash reference for the given package. The stash reference can be
treated like a hashref, you can get keys and values from it.
.ie n .IP "$slot = sig_to_slot($sigil)" 4
.el .IP "\f(CW$slot\fR = sig_to_slot($sigil)" 4
.IX Item "$slot = sig_to_slot($sigil)"
Given a sigil such as \f(CW\*(C`$\*(C'\fR, \f(CW\*(C`@\*(C'\fR, \f(CW\*(C`%\*(C'\fR, \f(CW\*(C`&\*(C'\fR, \f(CW\*(C`*\*(C'\fR, this will return the \s-1GLOB\s0
slot for that sigil such as \f(CW\*(C`SCALAR\*(C'\fR, \f(CW\*(C`ARRAY\*(C'\fR, \f(CW\*(C`HASH\*(C'\fR, \f(CW\*(C`CODE\*(C'\fR, \f(CW\*(C`GLOB\*(C'\fR.
.ie n .IP "$sigil = slot_to_sig($slot)" 4
.el .IP "\f(CW$sigil\fR = slot_to_sig($slot)" 4
.IX Item "$sigil = slot_to_sig($slot)"
Given a a glob slot such as \f(CW\*(C`SCALAR\*(C'\fR, \f(CW\*(C`ARRAY\*(C'\fR, \f(CW\*(C`HASH\*(C'\fR, \f(CW\*(C`CODE\*(C'\fR, \f(CW\*(C`GLOB\*(C'\fR,
this will return the typical sigil for that slot such as \f(CW\*(C`$\*(C'\fR, \f(CW\*(C`@\*(C'\fR, \f(CW\*(C`%\*(C'\fR,
\&\f(CW\*(C`&\*(C'\fR, \f(CW\*(C`*\*(C'\fR.
.ie n .IP "($name, $type) = parse_symbol($symbol)" 4
.el .IP "($name, \f(CW$type\fR) = parse_symbol($symbol)" 4
.IX Item "($name, $type) = parse_symbol($symbol)"
When given a symbol name such as \f(CW$foo\fR or \f(CW@bar\fR this will return the symbol
name, and the type name. If no sigil is present in the variable name it will
assume it is a subroutine and return the \f(CW\*(C`CODE\*(C'\fR type. \f(CW$symbol\fR should be a
string containing the name of the symbol with optional sigil.
.ie n .IP "my $cols = \fIterm_size()\fR" 4
.el .IP "my \f(CW$cols\fR = \fIterm_size()\fR" 4
.IX Item "my $cols = term_size()"
Attempts to find the width in columns (characters) of the current terminal.
Returns 80 as a safe bet if it cannot find it another way. This is most
accurate if Term::ReadKey is installed.
.ie n .IP "$type = rtype($ref)" 4
.el .IP "\f(CW$type\fR = rtype($ref)" 4
.IX Item "$type = rtype($ref)"
A normalization between \f(CW\*(C`Scalar::Util::reftype()\*(C'\fR and \f(CW\*(C`ref()\*(C'\fR.
.Sp
Always returns a string.
.Sp
Returns \f(CW\*(AqREGEXP\*(Aq\fR for regex types
.Sp
Returns \f(CW\*(Aq\*(Aq\fR for non-refs
.Sp
Otherwise returns what \f(CW\*(C`Scalar::Util::reftype()\*(C'\fR returns.
.ie n .IP "$addr_str = render_ref($ref)" 4
.el .IP "\f(CW$addr_str\fR = render_ref($ref)" 4
.IX Item "$addr_str = render_ref($ref)"
Always returns a string. For unblessed references this returns something like
\&\f(CW"SCALAR(0x...)"\fR. For blessed references it returns
\&\f(CW"My::Thing=SCALAR(0x...)"\fR. The only difference between this and \f(CW\*(C`$add_str =
"$thing"\*(C'\fR is that it ignores any overloading to ensure it is always the ref
address.
.ie n .IP "$bool = \s-1\fICAN_SET_SUB_NAME\s0()\fR" 4
.el .IP "\f(CW$bool\fR = \s-1\fICAN_SET_SUB_NAME\s0()\fR" 4
.IX Item "$bool = CAN_SET_SUB_NAME()"
A constant, it returns true if either Sub::Name or Sub::Util are
installed and have the code necessary to set a sub name.
.ie n .IP "set_sub_name($name, $coderef)" 4
.el .IP "set_sub_name($name, \f(CW$coderef\fR)" 4
.IX Item "set_sub_name($name, $coderef)"
When Sub::Name or Sub::Util are installed, this will be an alias to the
sub name setting function from one or the other. If neither are installed then
this will be a sub that throws an exception.
.Sp
If setting the sub name is something nice, but not strictly necessary, you can
use this conditionally with \f(CW\*(C`CAN_SET_SUB_NAME()\*(C'\fR.
.Sp
.Vb 2
\&    use Test::Stream::Util qw/CAN_SET_SUB_NAME set_sub_name/;
\&    set_sub_name(\*(Aqfoo\*(Aq, \e&sub) if CAN_SET_SUB_NAME();
.Ve
.ie n .IP "my $hr = sub_info(\e&code)" 4
.el .IP "my \f(CW$hr\fR = sub_info(\e&code)" 4
.IX Item "my $hr = sub_info(&code)"
This returns a hashref with information about the sub:
.Sp
.Vb 6
\&    {
\&        ref        => \e&code,
\&        cobj       => $cobj,
\&        name       => "Some::Mod::code",
\&        file       => "Some/Mod.pm",
\&        package    => "Some::Mod",
\&
\&        # Note: These have been adjusted based on guesswork.
\&        start_line => 22,
\&        end_line   => 42,
\&        lines      => [22, 42],
\&
\&        # Not a bug, these lines are different!
\&        all_lines  => [23, 25, ..., 39, 41],
\&    };
.Ve
.RS 4
.ie n .IP "$info\->{ref} => \e&code" 4
.el .IP "\f(CW$info\fR\->{ref} => \e&code" 4
.IX Item "$info->{ref} => &code"
This is the original sub passed to \f(CW\*(C`sub_info()\*(C'\fR.
.ie n .IP "$info\->{cobj} => $cobj" 4
.el .IP "\f(CW$info\fR\->{cobj} => \f(CW$cobj\fR" 4
.IX Item "$info->{cobj} => $cobj"
This is the c\-object representation of the coderef.
.ie n .IP "$info\->{name} => ""Some::Mod::code""" 4
.el .IP "\f(CW$info\fR\->{name} => ``Some::Mod::code''" 4
.IX Item "$info->{name} => Some::Mod::code"
This is the name of the coderef, for anonymous coderefs this may end with
\&\f(CW\*(Aq_\|_ANON_\|_\*(Aq\fR. Also note that the package 'main' is special, and 'main::' may
be omitted.
.ie n .IP "$info\->{file} => ""Some/Mod.pm""" 4
.el .IP "\f(CW$info\fR\->{file} => ``Some/Mod.pm''" 4
.IX Item "$info->{file} => Some/Mod.pm"
The file in which the sub was defined.
.ie n .IP "$info\->{package} => ""Some::Mod""" 4
.el .IP "\f(CW$info\fR\->{package} => ``Some::Mod''" 4
.IX Item "$info->{package} => Some::Mod"
The package in which the sub was defined.
.ie n .IP "$info\->{start_line} => 22" 4
.el .IP "\f(CW$info\fR\->{start_line} => 22" 4
.IX Item "$info->{start_line} => 22"
.PD 0
.ie n .IP "$info\->{end_line} => 42" 4
.el .IP "\f(CW$info\fR\->{end_line} => 42" 4
.IX Item "$info->{end_line} => 42"
.ie n .IP "$info\->{lines} => [22, 42]" 4
.el .IP "\f(CW$info\fR\->{lines} => [22, 42]" 4
.IX Item "$info->{lines} => [22, 42]"
.PD
These 3 fields are the \fIadjusted\fR start line, end line, and array with both.
It is important to note that these lines have been adjusted and may not be
accurate.
.Sp
The lines are obtained by walking the ops, as such the first line is the line
of the first statement, and the last line is the line of the last statement.
This means that in multi-line subs the lines are usually off by 1.  The lines
in these keys will be adjusted for you if it detects a multi-line sub.
.ie n .IP "$info\->{all_lines} => [23, 25, ..., 39, 41]" 4
.el .IP "\f(CW$info\fR\->{all_lines} => [23, 25, ..., 39, 41]" 4
.IX Item "$info->{all_lines} => [23, 25, ..., 39, 41]"
This is an array with the lines of every statement in the sub. unlike the other
line fields, these have not been adjusted for you.
.RE
.RS 4
.RE
.SH "SOURCE"
.IX Header "SOURCE"
The source code repository for Test::Stream can be found at
\&\fIhttp://github.com/Test\-More/Test\-Stream/\fR.
.SH "MAINTAINERS"
.IX Header "MAINTAINERS"
.IP "Chad Granum <exodist@cpan.org>" 4
.IX Item "Chad Granum <exodist@cpan.org>"
.SH "AUTHORS"
.IX Header "AUTHORS"
.PD 0
.IP "Chad Granum <exodist@cpan.org>" 4
.IX Item "Chad Granum <exodist@cpan.org>"
.IP "Kent Fredric <kentnl@cpan.org>" 4
.IX Item "Kent Fredric <kentnl@cpan.org>"
.PD
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2015 Chad Granum <exodist7@gmail.com>.
.PP
This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
.PP
See \fIhttp://www.perl.com/perl/misc/Artistic.html\fR
