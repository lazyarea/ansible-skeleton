.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Test::Stream::Plugin::Core 3"
.TH Test::Stream::Plugin::Core 3 "2015-10-13" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Test::Stream::Plugin::Core \- Test::Stream implementation of the core Test::More
tools.
.SH "EXPERIMENTAL CODE WARNING"
.IX Header "EXPERIMENTAL CODE WARNING"
\&\fBThis is an experimental release!\fR Test-Stream, and all its components are
still in an experimental phase. This dist has been released to cpan in order to
allow testers and early adopters the chance to write experimental new tools
with it, or to add experimental support for it into old tools.
.PP
\&\fB\s-1PLEASE DO NOT COMPLETELY CONVERT OLD TOOLS YET\s0\fR. This experimental release is
very likely to see a lot of code churn. \s-1API\s0's may break at any time.
Test-Stream should \s-1NOT\s0 be depended on by any toolchain level tools until the
experimental phase is over.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fBThis is not a drop-in replacement for Test::More\fR.
.PP
The new Testing library to replace Test::More. This library is directly
built on new internals instead of Test::Builder.
.PP
This module implements \fImost\fR of the same functionality as Test::More, but
since changing to this library from Test::More is not automatic, some
incompatible \s-1API\s0 changes have been made. If you decide to replace Test::More
in existing test files, you may have to update some function calls.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Test::Stream qw/Core/;
\&
\&    set_encoding(\*(Aqutf8\*(Aq);
\&
\&    plan($num); # Optional, set a plan
\&
\&    use Data::Dumper;
\&    imported_ok qw/Dumper/;
\&    not_imported_ok qw/dumper/;
\&
\&    # skip all tests in some condition
\&    skip_all("do not run") if $cond;
\&
\&    if ($passing) {
\&        pass(\*(Aqa passing test\*(Aq);
\&    }
\&    else {
\&        fail(\*(Aqa failing test\*(Aq);
\&    }
\&
\&    ok($x, "simple test");
\&
\&    # Check that the class or object has the specified methods defined.
\&    can_ok($class_or_obj, @methods);
\&
\&    # Check that the class or object is or subclasses the specified packages
\&    isa_ok($class_or_obj, @packages);
\&
\&    # Check that the class or object consumes the specified roles.
\&    DOES_ok($class_or_obj, @roles);
\&
\&    # Check that $ref is a HASH reference
\&    ref_ok($ref, \*(AqHASH\*(Aq, \*(AqMust be a hash\*(Aq)
\&
\&    # The preferred way to plan
\&    done_testing;
.Ve
.SH "EXPORTS"
.IX Header "EXPORTS"
All subs are exported by default.
.SS "\s-1ASSERTIONS\s0"
.IX Subsection "ASSERTIONS"
.IP "ok($bool)" 4
.IX Item "ok($bool)"
.PD 0
.ie n .IP "ok($bool, $name)" 4
.el .IP "ok($bool, \f(CW$name\fR)" 4
.IX Item "ok($bool, $name)"
.ie n .IP "ok($bool, $name, @diag)" 4
.el .IP "ok($bool, \f(CW$name\fR, \f(CW@diag\fR)" 4
.IX Item "ok($bool, $name, @diag)"
.PD
Simple assertion. If \f(CW$bool\fR is true the test passes, if it is false the test
fails. The test name is optional, and all arguments after the name are added as
diagnostics message if and only if the test fails. If the test passes all the
diagnostics arguments will be ignored.
.IP "\fIpass()\fR" 4
.IX Item "pass()"
.PD 0
.IP "pass($name)" 4
.IX Item "pass($name)"
.PD
Fire off a passing test (a single Ok event). The name is optional
.IP "\fIfail()\fR" 4
.IX Item "fail()"
.PD 0
.IP "fail($name)" 4
.IX Item "fail($name)"
.ie n .IP "fail($name, @diag)" 4
.el .IP "fail($name, \f(CW@diag\fR)" 4
.IX Item "fail($name, @diag)"
.PD
Fire off a failing test (a single Ok event). The name and diagnostics are optional.
.IP "imported_ok(@SUB_NAMES)" 4
.IX Item "imported_ok(@SUB_NAMES)"
Check that the specified subs have been defined in the current namespace. This
will \s-1NOT\s0 find inherited subs, the subs must be in the current namespace.
.IP "not_imported_ok(@SUB_NAMES)" 4
.IX Item "not_imported_ok(@SUB_NAMES)"
Check that the specified subs have \s-1NOT\s0 been defined in the current namespace.
This will \s-1NOT\s0 find inherited subs, the subs must be in the current namespace.
.ie n .IP "can_ok($thing, @methods)" 4
.el .IP "can_ok($thing, \f(CW@methods\fR)" 4
.IX Item "can_ok($thing, @methods)"
This checks that \f(CW$thing\fR (either a class name, or a blessed instance) has the
specified methods.
.ie n .IP "isa_ok($thing, @classes)" 4
.el .IP "isa_ok($thing, \f(CW@classes\fR)" 4
.IX Item "isa_ok($thing, @classes)"
This checks that \f(CW$thing\fR (either a class name, or a blessed instance) is or
subclasses the specified classes.
.ie n .IP "DOES_ok($thing, @roles)" 4
.el .IP "DOES_ok($thing, \f(CW@roles\fR)" 4
.IX Item "DOES_ok($thing, @roles)"
This checks that \f(CW$thing\fR (either a class name, or a blessed instance) does
the specified roles.
.IP "ref_ok($thing)" 4
.IX Item "ref_ok($thing)"
.PD 0
.ie n .IP "ref_ok($thing, $type)" 4
.el .IP "ref_ok($thing, \f(CW$type\fR)" 4
.IX Item "ref_ok($thing, $type)"
.ie n .IP "ref_ok($thing, $type, $name)" 4
.el .IP "ref_ok($thing, \f(CW$type\fR, \f(CW$name\fR)" 4
.IX Item "ref_ok($thing, $type, $name)"
.PD
This checks that \f(CW$thing\fR is a reference. If \f(CW$type\fR is specified then it
will check that \f(CW$thing\fR is that type of reference.
.ie n .IP "ref_is($ref1, $ref2, $name)" 4
.el .IP "ref_is($ref1, \f(CW$ref2\fR, \f(CW$name\fR)" 4
.IX Item "ref_is($ref1, $ref2, $name)"
Verify that 2 references are the exact same reference.
.ie n .IP "ref_is_not($ref1, $ref2, $name)" 4
.el .IP "ref_is_not($ref1, \f(CW$ref2\fR, \f(CW$name\fR)" 4
.IX Item "ref_is_not($ref1, $ref2, $name)"
Verify that 2 references are not the exact same reference.
.SS "\s-1DIAGNOSTICS\s0"
.IX Subsection "DIAGNOSTICS"
.IP "diag(@messages)" 4
.IX Item "diag(@messages)"
Write diagnostics messages. All items in \f(CW@messages\fR will be joined into a
single string with no seperator. When using \s-1TAP\s0 diagnostics are sent to \s-1STDERR.\s0
.IP "note(@messages)" 4
.IX Item "note(@messages)"
Write note-diagnostics messages. All items in \f(CW@messages\fR will be joined into
a single string with no seperator. When using \s-1TAP\s0 note-diagnostics are sent to
\&\s-1STDOUT.\s0
.SS "\s-1PLANNING\s0"
.IX Subsection "PLANNING"
.IP "plan($num)" 4
.IX Item "plan($num)"
Set the number of tests that are expected. This must be done first or last,
never in the middle of testing.
.IP "skip_all($reason)" 4
.IX Item "skip_all($reason)"
Set the plan to 0 with a reason, then exit true. This should be used before any
tests are run.
.IP "done_testing" 4
.IX Item "done_testing"
Used to mark the end of testing. This is a safe way to have a dynamic or
unknown number of tests.
.IP "\s-1BAIL_OUT\s0($reason)" 4
.IX Item "BAIL_OUT($reason)"
Something has gone horribly wrong, stop everything, kill all threads and
processes, end the process with a false exit status.
.SS "\s-1META\s0"
.IX Subsection "META"
.ie n .IP "$todo = todo($reason)" 4
.el .IP "\f(CW$todo\fR = todo($reason)" 4
.IX Item "$todo = todo($reason)"
.PD 0
.ie n .IP "todo $reason => sub { ... }" 4
.el .IP "todo \f(CW$reason\fR => sub { ... }" 4
.IX Item "todo $reason => sub { ... }"
.PD
This is used to mark some results as \s-1TODO. TODO\s0 means that the test may fail,
but will not cause the overall test suite to fail.
.Sp
There are 2 ways to use this, the first is to use a codeblock, the \s-1TODO\s0 will
only apply to the codeblock.
.Sp
.Vb 1
\&    ok(1, "before"); # Not TODO
\&
\&    todo \*(Aqthis will fail\*(Aq => sub {
\&        # This is TODO, as is any other test in this block.
\&        ok(0, "blah");
\&    };
\&
\&    ok(1, "after"); # Not TODO
.Ve
.Sp
The other way is to use a scoped variable, \s-1TODO\s0 will end when the variable is
destroyed or set to undef.
.Sp
.Vb 1
\&    ok(1, "before"); # Not TODO
\&
\&    {
\&        my $todo = todo \*(Aqthis will fail\*(Aq;
\&
\&        # This is TODO, as is any other test in this block.
\&        ok(0, "blah");
\&    };
\&
\&    ok(1, "after"); # Not TODO
.Ve
.Sp
This is the same thing, but without the \f(CW\*(C`{...}\*(C'\fR scope.
.Sp
.Vb 1
\&    ok(1, "before"); # Not TODO
\&
\&    my $todo = todo \*(Aqthis will fail\*(Aq;
\&
\&    ok(0, "blah"); # TODO
\&
\&    $todo = undef;
\&
\&    ok(1, "after"); # Not TODO
.Ve
.IP "skip($why)" 4
.IX Item "skip($why)"
.PD 0
.ie n .IP "skip($why, $count)" 4
.el .IP "skip($why, \f(CW$count\fR)" 4
.IX Item "skip($why, $count)"
.PD
This is used to skip some tests. This requires you to wrap your tests in a
block labeled \f(CW\*(C`SKIP:\*(C'\fR, this is somewhat magical. If no \f(CW$count\fR is specified
then it will issue a single result. If you specify \f(CW$count\fR it will issue that
many results.
.Sp
.Vb 2
\&    SKIP: {
\&        skip "This will wipe your drive";
\&
\&        # This never gets run:
\&        ok(!system(\*(Aqsudo rm \-rf /\*(Aq), "Wipe drive");
\&    }
.Ve
.IP "set_encoding($encoding)" 4
.IX Item "set_encoding($encoding)"
This will set the encoding to whatever you specify. This will only effect the
output of the current formatter, which is usually your \s-1TAP\s0 output formatter.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "Test::Stream::Subtest" 4
.IX Item "Test::Stream::Subtest"
Subtest support
.IP "Test::Stream::Intercept" 4
.IX Item "Test::Stream::Intercept"
Tools for intercepting events, exceptions, warnings, etc.
.IP "Test::Stream::Tester" 4
.IX Item "Test::Stream::Tester"
Tools for testing your test tools
.IP "Test::Stream::IPC" 4
.IX Item "Test::Stream::IPC"
Use this module directly for more control over concurrency.
.SH "SOURCE"
.IX Header "SOURCE"
The source code repository for Test::Stream can be found at
\&\fIhttp://github.com/Test\-More/Test\-Stream/\fR.
.SH "MAINTAINERS"
.IX Header "MAINTAINERS"
.IP "Chad Granum <exodist@cpan.org>" 4
.IX Item "Chad Granum <exodist@cpan.org>"
.SH "AUTHORS"
.IX Header "AUTHORS"
.PD 0
.IP "Chad Granum <exodist@cpan.org>" 4
.IX Item "Chad Granum <exodist@cpan.org>"
.PD
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2015 Chad Granum <exodist7@gmail.com>.
.PP
This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
.PP
See \fIhttp://www.perl.com/perl/misc/Artistic.html\fR
