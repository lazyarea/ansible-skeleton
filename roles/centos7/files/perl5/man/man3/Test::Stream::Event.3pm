.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Test::Stream::Event 3"
.TH Test::Stream::Event 3 "2015-10-13" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Test::Stream::Event \- Base class for events
.SH "EXPERIMENTAL CODE WARNING"
.IX Header "EXPERIMENTAL CODE WARNING"
\&\fBThis is an experimental release!\fR Test-Stream, and all its components are
still in an experimental phase. This dist has been released to cpan in order to
allow testers and early adopters the chance to write experimental new tools
with it, or to add experimental support for it into old tools.
.PP
\&\fB\s-1PLEASE DO NOT COMPLETELY CONVERT OLD TOOLS YET\s0\fR. This experimental release is
very likely to see a lot of code churn. \s-1API\s0's may break at any time.
Test-Stream should \s-1NOT\s0 be depended on by any toolchain level tools until the
experimental phase is over.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Base class for all event objects that get passed through
Test::Stream.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&    package Test::Stream::Event::MyEvent;
\&    use strict;
\&    use warnings;
\&
\&    # This will make our class an event subclass, add the specified accessors,
\&    # add constants for all our fields, and fields we inherit.
\&    use Test::Stream::Event(
\&        accessors  => [qw/foo bar baz/],
\&    );
\&
\&    # Chance to initialize some defaults
\&    sub init {
\&        my $self = shift;
\&        # no other args in @_
\&
\&        $self\->SUPER::init();
\&
\&        $self\->set_foo(\*(Aqxxx\*(Aq) unless defined $self\->foo;
\&
\&        # Events are arrayrefs, all accessors have a constant defined with
\&        # their index.
\&        $self\->[BAR] ||= "";
\&
\&        ...
\&    }
\&
\&    1;
.Ve
.SH "IMPORTING"
.IX Header "IMPORTING"
.SS "\s-1ARGUMENTS\s0"
.IX Subsection "ARGUMENTS"
In addition to the arguments listed here, you may pass in any arguments
accepted by Test::Stream::HashBase.
.ie n .IP "base => $BASE_CLASS" 4
.el .IP "base => \f(CW$BASE_CLASS\fR" 4
.IX Item "base => $BASE_CLASS"
This lets you specify an event class to subclass. \fB\s-1THIS MUST BE AN EVENT
CLASS\s0\fR. If you do not specify anything here then \f(CW\*(C`Test::Stream::Event\*(C'\fR will be
used.
.IP "accessors => \e@FIELDS" 4
.IX Item "accessors => @FIELDS"
This lets you define any fields you wish to be present in your class. This is
the only way to define storage for your event. Each field specified will get a
read-only accessor with the same name as the field, as well as a setter
\&\f(CW\*(C`set_FIELD()\*(C'\fR. You will also get a constant that returns the index of the
field in the classes arrayref. The constant is the name of the field in all
upper-case.
.SS "\s-1SUBCLASSING\s0"
.IX Subsection "SUBCLASSING"
\&\f(CW\*(C`Test::Stream::Event\*(C'\fR is added to your \f(CW@INC\fR for you, unless you specify an
alternative base class, which must itself subclass \f(CW\*(C`Test::Stream::Event\*(C'\fR.
.SH "METHODS"
.IX Header "METHODS"
.ie n .IP "$dbg = $e\->debug" 4
.el .IP "\f(CW$dbg\fR = \f(CW$e\fR\->debug" 4
.IX Item "$dbg = $e->debug"
Get a snapshot of the debug info as it was when this event was generated
.ie n .IP "$bool = $e\->causes_fail" 4
.el .IP "\f(CW$bool\fR = \f(CW$e\fR\->causes_fail" 4
.IX Item "$bool = $e->causes_fail"
Returns true if this event should result in a test failure. In general this
should be false.
.ie n .IP "$call = $e\->created" 4
.el .IP "\f(CW$call\fR = \f(CW$e\fR\->created" 4
.IX Item "$call = $e->created"
Get the \f(CW\*(C`caller()\*(C'\fR details from when the event was generated. This is usually
inside a tools package. This is typically used for debugging.
.ie n .IP "$num = $e\->nested" 4
.el .IP "\f(CW$num\fR = \f(CW$e\fR\->nested" 4
.IX Item "$num = $e->nested"
If this event is nested inside of other events, this should be the depth of
nesting. (This is mainly for subtests)
.ie n .IP "$e\->update_state($state)" 4
.el .IP "\f(CW$e\fR\->update_state($state)" 4
.IX Item "$e->update_state($state)"
This callback is used by Test::Stream::Hub to give your event a chance to
update the state.
.Sp
This is called \fB\s-1BEFORE\s0\fR your event is passed to the formatter.
.ie n .IP "$bool = $e\->global" 4
.el .IP "\f(CW$bool\fR = \f(CW$e\fR\->global" 4
.IX Item "$bool = $e->global"
Set this to true if your event is global, that is \s-1ALL\s0 threads and processes
should see it no matter when or where it is generated. This is not a common
thing to want, it is used by bail-out and skip_all to end testing.
.ie n .IP "$code = $e\->terminate" 4
.el .IP "\f(CW$code\fR = \f(CW$e\fR\->terminate" 4
.IX Item "$code = $e->terminate"
This is called \fB\s-1AFTER\s0\fR your event has been passed to the formatter. This
should normally return undef, only change this if your event should cause the
test to exit immedietly.
.Sp
If you want this event to cause the test to exit you should return the exit
code here. Exit code of 0 means exit success, any other integer means exit with
failure.
.Sp
This is used by Test::Stream::Event::Plan to exit 0 when the plan is
\&'skip_all'. This is also used by Test::Stream::Event:Bail to force the test
to exit with a failure.
.Sp
This is called after the event has been sent to the formatter in order to
ensure the event is seen and understood.
.ie n .IP "@output = $e\->to_tap($num)" 4
.el .IP "\f(CW@output\fR = \f(CW$e\fR\->to_tap($num)" 4
.IX Item "@output = $e->to_tap($num)"
This is where you get the chance to produce \s-1TAP\s0 output. The input argument
\&\f(CW$num\fR will either be the most recent test number, or undefined. The output
should be a list of arrayrefs, each arrayref should have exactly 2 values:
\&\f(CW\*(C`$HID, $TEXT\*(C'\fR. The \s-1HID\s0 tells the formatter which output handle to use (see the
constants provided by Test::Stream::Formatter::TAP), \f(CW$TEXT\fR should be the text that
is output to the specified handle.
.Sp
Example:
.Sp
.Vb 3
\&    package Test::Stream::Event::MyEvent;
\&    use Test::Stream::Event;
\&    use Test::Stream::Formatter::TAP qw/OUT_STD OUT_TODO OUT_ERR/;
\&
\&    sub to_tap {
\&        my $self = shift;
\&        my ($num) = @_;
\&
\&        # Using test numbers
\&        if (defined $num) {
\&            return (
\&                [OUT_STD, "# Got MyEvent!"],
\&                [OUT_ERR, "# The last test was $num"],
\&            );
\&        }
\&
\&        # Not using test numbers.
\&        return (
\&            [OUT_STD, "# Got MyEvent!"],
\&        );
\&    }
.Ve
.SH "SOURCE"
.IX Header "SOURCE"
The source code repository for Test::Stream can be found at
\&\fIhttp://github.com/Test\-More/Test\-Stream/\fR.
.SH "MAINTAINERS"
.IX Header "MAINTAINERS"
.IP "Chad Granum <exodist@cpan.org>" 4
.IX Item "Chad Granum <exodist@cpan.org>"
.SH "AUTHORS"
.IX Header "AUTHORS"
.PD 0
.IP "Chad Granum <exodist@cpan.org>" 4
.IX Item "Chad Granum <exodist@cpan.org>"
.PD
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2015 Chad Granum <exodist7@gmail.com>.
.PP
This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
.PP
See \fIhttp://www.perl.com/perl/misc/Artistic.html\fR
