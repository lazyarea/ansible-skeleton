.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Test::Stream 3"
.TH Test::Stream 3 "2015-10-13" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Test::Stream \- Experimental successor to Test::More and Test::Builder.
.SH "EXPERIMENTAL CODE WARNING"
.IX Header "EXPERIMENTAL CODE WARNING"
\&\fBThis is an experimental release!\fR Test-Stream, and all its components are
still in an experimental phase. This dist has been released to cpan in order to
allow testers and early adopters the chance to write experimental new tools
with it, or to add experimental support for it into old tools.
.PP
\&\fB\s-1PLEASE DO NOT COMPLETELY CONVERT OLD TOOLS YET\s0\fR. This experimental release is
very likely to see a lot of code churn. \s-1API\s0's may break at any time.
Test-Stream should \s-1NOT\s0 be depended on by any toolchain level tools until the
experimental phase is over.
.SH "***READ THIS FIRST***"
.IX Header "***READ THIS FIRST***"
\&\fBThis is not a drop-in replacement for Test::More\fR.
.PP
Adoption of Test::Stream instead of continuing to use Test::More is a
choice. Liberty has been taken to make significant \s-1API\s0 changes. Replacing \f(CW\*(C`use
Test::More;\*(C'\fR with \f(CW\*(C`use Test::Stream;\*(C'\fR will not work for more than the most
trivial of test files.
.PP
See Test::Stream::Manual::FromTestBuilder if you are coming from
Test::More or Test::Simple and want a quick translation.
.SH "MANUAL"
.IX Header "MANUAL"
\&\s-1TODO:\s0 Manual
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is the primary interface for loading Test::Stream based tools. This
module is responsible for loading bundles and plugins for the tools you want.
Test::Stream::Bundle::V1 is the suggested bundle for those just starting
out.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Test::Stream \-V1;
\&
\&    ok(1, "This is a pass");
\&    ok(0, "This is a fail");
\&
\&    is("x", "x", "These strings are the same");
\&    is($A, $B, "These 2 structures match exactly");
\&
\&    like(\*(Aqx\*(Aq, qr/x/, "This string matches this pattern");
\&    like($A, $B, "These structures match where it counts");
\&
\&    done_testing;
.Ve
.SH "IMPORTANT NOTE"
.IX Header "IMPORTANT NOTE"
\&\f(CW\*(C`use Test::Stream;\*(C'\fR will fail. You \fB\s-1MUST\s0\fR specify at least 1 bundle or
plugin. If you do not specify any then none would be imported and that is
obviously not what you want. If you are new to Test::Stream then you should
probably start with the '\-V1' argument, which loads
Test::Stream::Bundle::V1. The V1 bundle provides the most commonly
needed tools.
.SS "\s-1WHY NOT MAKE A DEFAULT BUNDLE OR SET OF PLUGINS\s0?"
.IX Subsection "WHY NOT MAKE A DEFAULT BUNDLE OR SET OF PLUGINS?"
Future Proofing. If we decide in the future that a specific plugin or tool is
harmful we would like to be able to remove it. Making a tool part of the
default set will effectively make it unremovable as doing so would break
compatability. To solve this problem we have the 'Core#' bundle system.
.PP
\&'V1' is the first bundle, and the recommended one for now. If the future tells
us that parts of 'V1' are harmful, or that we need more than what is currently
provided, we can release 'V2'. 'V1' will not be changed in a backwords
incompatible way, so nothing breaks, but everyone else can move on and start
using 'V2' in new code.
.PP
The number following the 'V' prefix should correspond to a major version
number. This means that 'V1' is provided with Test::Stream 1.X. V2
will prompt a 2.X release and so on.
.SH "PLUGINS, BUNDLES, AND OPTIONS"
.IX Header "PLUGINS, BUNDLES, AND OPTIONS"
Test::Stream tools should be created as plugins. This is not enforced,
nothing prevents you from writing Test::Stream tools that are not plugins.
However writing your tool as a plugin will help your module to play well with
other tools. Writing a plugin also makes it easier for you to create private or
public bundles that reduce your boilerplate.
.PP
Bundles are very simple. At its core a bundle is simply a list of other
bundles, plugins, and arguments to those plugins. Much like hash declaration a
\&'last wins' approach is used; if you load 2 bundles that share a plugin with
different arguments, the last set of arguments wins.
.PP
Plugins and bundles can be distinguished easily:
.PP
.Vb 10
\&    use Test::Stream(
\&        \*(Aq\-V1\*(Aq,                          # Bundle (\*(Aq\-\*(Aq)
\&        \*(Aq:Project\*(Aq,                     # Project specific bundle (\*(Aq:\*(Aq)
\&        \*(AqMyPlugin\*(Aq,                     # Plugin name (no prefix)
\&        \*(Aq+Fully::Qualified::Plugin\*(Aq,    # (Plugin in unusual path)
\&        \*(AqSomePlugin\*(Aq => [\*(Aqarg1\*(Aq, ...],  # (Plugin with args)
\&        \*(Aq!UnwantedPlugin\*(Aq,              # Do not load this plugin
\&        \*(AqWantEverything\*(Aq => \*(Aq*\*(Aq,        # Load the plugin with all options
\&        \*(Aqoption\*(Aq => ...,                # Option to the loader (Test::Stream)
\&    );
.Ve
.PP
Explanation:
.IP "'\-V1'," 4
.IX Item "'-V1',"
The \f(CW\*(C`\-\*(C'\fR prefix indicates that the specified item is a bundle. Bundles live in
the \f(CW\*(C`Test::Stream::Bundle::\*(C'\fR namespace. Each bundle is an independant module.
You can specify any number of bundles, or none at all.
.IP "':Project'" 4
.IX Item "':Project'"
The ':' prefix indicates we are loading a project specific bundle, which means
the module must be located in \f(CW\*(C`t/lib/\*(C'\fR, \f(CW\*(C`lib/\*(C'\fR, or the paths provided in the
\&\f(CW\*(C`TS_LB_PATH\*(C'\fR environment variable. In the case of ':Project' it will look for
\&\f(CW\*(C`Test/Stream/Bundle/Project.pm\*(C'\fR in \f(CW\*(C`TS_LB_PATH\*(C'\fR, \f(CW\*(C`t/lib/\*(C'\fR, then \f(CW\*(C`lib/\*(C'\fR.
.Sp
This is a good way to create bundles useful to your project, but not really
worth putting on \s-1CPAN.\s0
.IP "'MyPlugin'" 4
.IX Item "'MyPlugin'"
Arguments without a prefix are considered to be plugin names. Plugins are
assumed to be in \f(CW\*(C`Test::Stream::Plugin::\*(C'\fR, which is prefixed automatically for
you.
.IP "'+Fully::Qualified::Plugin'" 4
.IX Item "'+Fully::Qualified::Plugin'"
If you write a plugin, but put it in a non-standard namespace, you can use the
fully qualified plugin namespace prefixed by '+'. Apart from the namespace
treatment there is no difference in how the plugin is loaded or used.
.IP "'SomePlugin' => \e@ARGS" 4
.IX Item "'SomePlugin' => @ARGS"
Most plugins provide a fairly sane set of defaults when loaded. However some
provide extras you need to request. When loading a plugin directly these would
be the import arguments. If you plugin is followed by an arrayref the ref
contents will be used as load arguments.
.Sp
Bundles may also specify arguments for plugins. You can override the bundles
arguments by specifying your own. In these cases last wins, arguments are never
merged. If multiple bundles are loaded, and several specify arguments to the
same plugin, the same rules apply.
.Sp
.Vb 5
\&    use Test::Stream(
\&        \*(Aq\-BundleFoo\*(Aq,         # Arguments to \*(AqFoo\*(Aq get squashed by the next bundle
\&        \*(Aq\-BundleAlsoWithFoo\*(Aq, # Arguments to \*(AqFoo\*(Aq get squashed by the next line
\&        \*(AqFoo\*(Aq => [...],       # These args win
\&    );
.Ve
.IP "'!UnwantedPlugin'" 4
.IX Item "'!UnwantedPlugin'"
This will blacklist the plugin so that it will not be used. The blacklist will
block the plugin regardless of where it is listed. The blacklist only effects
the statement in which it appears; if you load Test::Stream twice, the
blacklist will only apply to the load in which it appears. You cannot override
the blacklist items.
.IP "'WantEverything' => '*'" 4
.IX Item "'WantEverything' => '*'"
This will load the plugin with all options. The '*' gets turned into
\&\f(CW\*(C`[\*(Aq\-all\*(Aq]\*(C'\fR for you.
.IP "'option' => ..." 4
.IX Item "'option' => ..."
Uncapitalized options without a \f(CW\*(C`+\*(C'\fR, \f(CW\*(C`\-\*(C'\fR, or \f(CW\*(C`:\*(C'\fR prefix are reserved for use
by the loader. Loaders that subclass Test::Stream can add options of their own.
.Sp
To define an option in your subclass simply add a \f(CW\*(C`sub opt_NAME()\*(C'\fR method. The
method will recieve several arguments:
.Sp
.Vb 3
\&    sub opt_foo {
\&        my $class = shift;
\&        my %params = @_;
\&
\&        my $list  = $params{list};  # List of remaining plugins/args
\&        my $args  = $params{args};  # Hashref of {plugin => \e@args}
\&        my $order = $params{order}; # Plugins to load, in order
\&        my $skip  = $params{skip};  # Hashref of plugins to skip {plugin => $bool}
\&
\&        # Pull our arguments off the list given at load time
\&        my $foos_arg = shift @$list;
\&
\&        # Add the \*(AqFoo\*(Aq plugin to the list of plugins to load, unless it is
\&        # present in the $args hash in which case it is already in order.
\&        push @$order => \*(AqFoo\*(Aq unless $args{\*(AqFoo\*(Aq};
\&
\&        # Set the args for the plugin
\&        $args\->{Foo} = [$foos_arg];
\&
\&        $skip{Fox} = 1; # Make sure the Fox plugin never loads.
\&    }
.Ve
.SS "\s-1AVAILABLE OPTIONS\s0"
.IX Subsection "AVAILABLE OPTIONS"
.ie n .IP "class => $CLASS" 4
.el .IP "class => \f(CW$CLASS\fR" 4
.IX Item "class => $CLASS"
Shortcut for the Test::Stream::Plugin::Class plugin.
.ie n .IP "skip_without => $MODULE" 4
.el .IP "skip_without => \f(CW$MODULE\fR" 4
.IX Item "skip_without => $MODULE"
.PD 0
.IP "skip_without => 'v5.008'" 4
.IX Item "skip_without => 'v5.008'"
.ie n .IP "skip_without => [$MODULE => $VERSION]" 4
.el .IP "skip_without => [$MODULE => \f(CW$VERSION\fR]" 4
.IX Item "skip_without => [$MODULE => $VERSION]"
.PD
Shortcup for the Test::Stream::Plugin::SkipWithout plugin. Unlike normal
specification of a plugin, this \s-1APPENDS\s0 arguments. This one can be called
several time and the arguments will be appended.
.Sp
\&\fBNote:\fR specifying 'SkipWithout' the normal way after a call to 'skip_without'
will wipe out the argument that have accumulated so far.
.ie n .IP "srand => $SEED" 4
.el .IP "srand => \f(CW$SEED\fR" 4
.IX Item "srand => $SEED"
Shortcut to set the random seed.
.SS "\s-1SEE ALSO\s0"
.IX Subsection "SEE ALSO"
For more about plugins and bundles see the following docs:
.IP "plugins" 4
.IX Item "plugins"
Test::Stream::Plugin \- Provides tools to help write plugins.
.IP "bundles" 4
.IX Item "bundles"
Test::Stream::Bundle \- Provides tools to help write bundles.
.SS "\s-1EXPLANATION AND HISTORY\s0"
.IX Subsection "EXPLANATION AND HISTORY"
Test::Stream has learned from Test::Builder. For a time it was common for
people to write \f(CW\*(C`Test::*\*(C'\fR tools that bundled other \f(CW\*(C`Test::*\*(C'\fR tools with them
when loaded. For a short time this seemed like a good idea. This was quickly
seen to be a problem when people wanted to use features of multiple testing
tools that both made incompatible assumptions about other modules you might
want to load.
.PP
Test::Stream does not recreate this wild west approach to testing tools and
bundles. Test::Stream recognises the benefits of bundles, but provides a
much more sane approach. Bundles and Tools are kept seperate, this way you can
always use tools without being forced to adopt the authors ideal bundle.
.SH "ENVIRONMENT VARIABLES"
.IX Header "ENVIRONMENT VARIABLES"
This is a list of environment variables Test::Stream looks at:
.ie n .IP "TS_FORMATTER=""Foo""" 4
.el .IP "TS_FORMATTER=``Foo''" 4
.IX Item "TS_FORMATTER=Foo"
.PD 0
.ie n .IP "TS_FORMATTER=""+Foo::Bar""" 4
.el .IP "TS_FORMATTER=``+Foo::Bar''" 4
.IX Item "TS_FORMATTER=+Foo::Bar"
.PD
This can be used to set the output formatter. By default
Test::Stream::Formatter::TAP is used.
.Sp
Normally 'Test::Stream::Formatter::' is prefixed to the value in the
environment variable:
.Sp
.Vb 2
\&    $ TS_FORMATTER=\*(AqTAP\*(Aq perl test.t     # Use the Test::Stream::Formatter::TAP formatter
\&    $ TS_FORMATTER=\*(AqFoo\*(Aq perl test.t     # Use the Test::Stream::Formatter::Foo formatter
.Ve
.Sp
If you want to specify a full module name you use the '+' prefix:
.Sp
.Vb 1
\&    $ TS_FORMATTER=\*(Aq+Foo::Bar\*(Aq perl test.t     # Use the Foo::Bar formatter
.Ve
.IP "TS_KEEP_TEMPDIR=1" 4
.IX Item "TS_KEEP_TEMPDIR=1"
Some \s-1IPC\s0 drivers make use of temporary directories, this variable will tell
Test::Stream to keep the directory when the tests are complete.
.ie n .IP "TS_LB_PATH=""./:./lib/:...""" 4
.el .IP "TS_LB_PATH=``./:./lib/:...''" 4
.IX Item "TS_LB_PATH=./:./lib/:..."
This allows you to provide paths where Test::Stream will search for project
specific bundles. These paths are \s-1NOT\s0 added to \f(CW@INC\fR.
.IP "TS_MAX_DELTA=25" 4
.IX Item "TS_MAX_DELTA=25"
This is used by the Test::Stream::Plugin::Compare plugin. This specifies the
max number of differences to show when data structures do not match.
.IP "TS_TERM_SIZE=80" 4
.IX Item "TS_TERM_SIZE=80"
This is used to set the width of the terminal. This is used when building
tables of diagnostics. The default is 80, unless Term::ReadKey is installed
in which case the value is determined dynamically.
.IP "TS_WORKFLOW=42" 4
.IX Item "TS_WORKFLOW=42"
.PD 0
.ie n .IP "TS_WORKFLOW=""foo""" 4
.el .IP "TS_WORKFLOW=``foo''" 4
.IX Item "TS_WORKFLOW=foo"
.PD
This is used by the Test::Stream::Plugin::Spec plugin to specify which test
block should be run, only the specified block will be run.
.IP "TS_RAND_SEED=44523" 4
.IX Item "TS_RAND_SEED=44523"
This only works when used with the Test::Stream::Plugin::SRand plugin. This
lets you specify the random seed to use.
.IP "\s-1HARNESS_ACTIVE\s0" 4
.IX Item "HARNESS_ACTIVE"
This is typically set by TAP::Harness and other harnesses. You should not
need to set this yourself.
.IP "\s-1HARNESS_IS_VERBOSE\s0" 4
.IX Item "HARNESS_IS_VERBOSE"
This is typically set by TAP::Harness and other harnesses. You should not
need to set this yourself.
.SH "SOURCE"
.IX Header "SOURCE"
The source code repository for Test::Stream can be found at
\&\fIhttp://github.com/Test\-More/Test\-Stream/\fR.
.SH "MAINTAINERS"
.IX Header "MAINTAINERS"
.IP "Chad Granum <exodist@cpan.org>" 4
.IX Item "Chad Granum <exodist@cpan.org>"
.SH "AUTHORS"
.IX Header "AUTHORS"
.PD 0
.IP "Chad Granum <exodist@cpan.org>" 4
.IX Item "Chad Granum <exodist@cpan.org>"
.PD
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2015 Chad Granum <exodist7@gmail.com>.
.PP
This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
.PP
See \fIhttp://www.perl.com/perl/misc/Artistic.html\fR
