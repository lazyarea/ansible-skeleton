.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "KyotoCabinet 3"
.TH KyotoCabinet 3 "2012-05-25" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
KyotoCabinet \- a straightforward implementation of DBM
.SH "SYNOPSYS"
.IX Header "SYNOPSYS"
.Vb 1
\& use KyotoCabinet;
.Ve
.SH "INTRODUCTION"
.IX Header "INTRODUCTION"
Kyoto Cabinet is a library of routines for managing a database.  The database is a simple data file containing records, each is a pair of a key and a value.  Every key and value is serial bytes with variable length.  Both binary data and character string can be used as a key and a value.  Each key must be unique within a database.  There is neither concept of data tables nor data types.  Records are organized in hash table or B+ tree.
.PP
The following access methods are provided to the database: storing a record with a key and a value, deleting a record by a key, retrieving a record by a key.  Moreover, traversal access to every key are provided.  These access methods are similar to ones of the original \s-1DBM \s0(and its followers: \s-1NDBM\s0 and \s-1GDBM\s0) library defined in the \s-1UNIX\s0 standard.  Kyoto Cabinet is an alternative for the \s-1DBM\s0 because of its higher performance.
.PP
Each operation of the hash database has the time complexity of \*(L"O(1)\*(R".  Therefore, in theory, the performance is constant regardless of the scale of the database.  In practice, the performance is determined by the speed of the main memory or the storage device.  If the size of the database is less than the capacity of the main memory, the performance will seem on-memory speed, which is faster than std::map of \s-1STL. \s0 Of course, the database size can be greater than the capacity of the main memory and the upper limit is 8 exabytes.  Even in that case, each operation needs only one or two seeking of the storage device.
.PP
Each operation of the B+ tree database has the time complexity of \*(L"O(log N)\*(R".  Therefore, in theory, the performance is logarithmic to the scale of the database.  Although the performance of random access of the B+ tree database is slower than that of the hash database, the B+ tree database supports sequential access in order of the keys, which realizes forward matching search for strings and range search for integers.  The performance of sequential access is much faster than that of random access.
.PP
This library wraps the polymorphic database of the \*(C+ \s-1API. \s0 So, you can select the internal data structure by specifying the database name in runtime.  This library is \s-1NOT\s0 thread-safe for Perl ithread.
.SH "INSTALLATION"
.IX Header "INSTALLATION"
Install the latest version of Kyoto Cabinet beforehand and get the package of the Perl binding of Kyoto Cabinet.
.PP
Enter the directory of the extracted package then perform installation.
.PP
.Vb 4
\& perl Makefile.PL
\& make
\& su
\& make install
.Ve
.PP
The package `KyotoCabinet' should be loaded in each source file of application programs.
.PP
.Vb 1
\& use KyotoCabinet;
.Ve
.PP
An instance of the class `\s-1DB\s0' is used in order to handle a database.  You can store, delete, and retrieve records with the instance.
.SH "EXAMPLE"
.IX Header "EXAMPLE"
The following code is a typical example to use a database.
.PP
.Vb 1
\& use KyotoCabinet;
\& 
\& # create the database object
\& my $db = new KyotoCabinet::DB;
\& 
\& # open the database
\& if (!$db\->open(\*(Aqcasket.kch\*(Aq, $db\->OWRITER | $db\->OCREATE)) {
\&     printf STDERR ("open error: %s\en", $db\->error);
\& }
\& 
\& # store records
\& if (!$db\->set(\*(Aqfoo\*(Aq, \*(Aqhop\*(Aq) ||
\&     !$db\->set(\*(Aqbar\*(Aq, \*(Aqstep\*(Aq) ||
\&     !$db\->set(\*(Aqbaz\*(Aq, \*(Aqjump\*(Aq)) {
\&     printf STDERR ("set error: %s\en", $db\->error);
\& }
\& 
\& # retrieve records
\& my $value = $db\->get(\*(Aqfoo\*(Aq);
\& if (defined($value)) {
\&     printf("%s\en", $value);
\& } else {
\&     printf STDERR ("get error: %s\en", $db\->error);
\& }
\& 
\& # traverse records
\& my $cur = $db\->cursor;
\& $cur\->jump;
\& while (my ($key, $value) = $cur\->get(1)) {
\&     printf("%s:%s\en", $key, $value);
\& }
\& $cur\->disable;
\& 
\& if (!$db\->close) {
\&     printf STDERR ("close error: %s\en", $db\->error);
\& }
.Ve
.PP
The following code is a more complex example, which uses the Visitor pattern.
.PP
.Vb 1
\& use KyotoCabinet;
\& 
\& # create the database object
\& my $db = new KyotoCabinet::DB;
\& 
\& # open the database
\& if (!$db\->open(\*(Aqcasket.kch\*(Aq, $db\->OREADER)) {
\&     printf STDERR ("open error: %s\en", $db\->error);
\& }
\& 
\& # define the visitor
\& {
\&     package VisitorImpl;
\&     use base qw(KyotoCabinet::Visitor);
\&     # constructor
\&     sub new {
\&         my $self = new KyotoCabinet::Visitor;
\&         bless $self;
\&         return $self;
\&     }
\&     # call back function for an existing record
\&     sub visit_full {
\&         my ($self, $key, $value) = @_;
\&         printf("%s:%s\en", $key, $value);
\&         return $self\->NOP;
\&     }
\&     # call back function for an empty record space
\&     sub visit_empty {
\&         my ($self, $key) = @_;
\&         printf STDERR ("%s is missing\en", $key);
\&         return $self\->NOP;
\&     }
\& }
\& my $visitor = new VisitorImpl;
\& 
\& # retrieve a record with visitor
\& if (!$db\->accept("foo", $visitor, 0) ||
\&     !$db\->accept("dummy", $visitor, 0)) {
\&     printf STDERR ("accept error: %s\en", $db\->error);
\& }
\& 
\& # traverse records with visitor
\& if (!$db\->iterate($visitor, 0)) {
\&     printf STDERR ("iterate error: %s\en", $db\->error);
\& }
\& 
\& # close the database
\& if (!$db\->close) {
\&     printf STDERR ("close error: %s\en", $db\->error);
\& }
.Ve
.PP
The following code is also a complex example, which is suited to the Perl style.
.PP
.Vb 1
\& use KyotoCabinet;
\& 
\& # tie a hash variable to the database
\& my $db = tie(my %db, \*(AqKyotoCabinet::DB\*(Aq, \*(Aqcasket.kch\*(Aq);
\& 
\& # store records
\& $db{\*(Aqfoo\*(Aq} = \*(Aqhop\*(Aq;   # string is fundamental
\& $db{bar} = \*(Aqstep\*(Aq;    # omitting quotation is ok
\& $db{3} = \*(Aqjump\*(Aq;      # number is also ok
\& 
\& # retrieve a record value
\& printf("%s\en", $db{\*(Aqfoo\*(Aq});
\& 
\& # update records in transaction
\& $db\->transaction(sub {
\&     $db{\*(Aqfoo\*(Aq} = 2.71828;
\&     1;
\& });
\& 
\& # multiply a record value
\& $db\->accept(\*(Aqfoo\*(Aq, sub {
\&     my ($key, $value) = @_;
\&     $value * 2;
\& });
\& 
\& # traverse records by iterator
\& while (my ($key, $value) = each(%db)) {
\&     printf("%s:%s\en", $key, $value);
\& }
\& 
\& # upcase values by iterator
\& $db\->iterate(sub {
\&     my ($key, $value) = @_;
\&     uc($value);
\& });
\& 
\& # traverse records by cursor
\& $db\->cursor_process(sub {
\&     my ($cur) = @_;
\&     $cur\->jump;
\&     while ($cur\->accept(sub {
\&             my ($key, $value) = @_;
\&             printf("%s:%s\en", $key, $value);
\&             KyotoCabinet::Visitor::NOP;
\&         })) {
\&         $cur\->step;
\&     }
\& });
\& 
\& # untie the hash variable
\& undef($db);
\& untie(%db);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.SS "Class KyotoCabinet"
.IX Subsection "Class KyotoCabinet"
Namespace of Kyoto Cabinet.
.IP "\fIKyotoCabinet::VERSION()\fR" 4
.IX Item "KyotoCabinet::VERSION()"

The version information.
.IP "KyotoCabinet::atoi(\fIstr\fR)" 4
.IX Item "KyotoCabinet::atoi(str)"

Convert a string to an integer.

\&\f(CW@param\fR str specifies the string.

\&\f(CW@return\fR the integer.  If the string does not contain numeric expression, 0 is returned.
.IP "KyotoCabinet::atoix(\fIstr\fR)" 4
.IX Item "KyotoCabinet::atoix(str)"

Convert a string with a metric prefix to an integer.

\&\f(CW@param\fR str the string, which can be trailed by a binary metric prefix.  \*(L"K\*(R", \*(L"M\*(R", \*(L"G\*(R", \*(L"T\*(R", \*(L"P\*(R", and \*(L"E\*(R" are supported.  They are case-insensitive.

\&\f(CW@return\fR the integer.  If the string does not contain numeric expression, 0 is returned.  If the integer overflows the domain, \s-1INT64_MAX\s0 or \s-1INT64_MIN\s0 is returned according to the sign.
.IP "KyotoCabinet::atof(\fIstr\fR)" 4
.IX Item "KyotoCabinet::atof(str)"

Convert a string to a real number.

\&\f(CW@param\fR str specifies the string.

\&\f(CW@return\fR the real number.  If the string does not contain numeric expression, 0.0 is returned.
.IP "KyotoCabinet::hash_murmur(\fIstr\fR)" 4
.IX Item "KyotoCabinet::hash_murmur(str)"

Get the hash value of a string by MurMur hashing.

\&\f(CW@param\fR str the string.

\&\f(CW@return\fR the hash value.
.IP "KyotoCabinet::hash_fnv(\fIstr\fR)" 4
.IX Item "KyotoCabinet::hash_fnv(str)"

Get the hash value of a string by \s-1FNV\s0 hashing.

\&\f(CW@param\fR str the string.

\&\f(CW@return\fR the hash value.
.IP "KyotoCabinet::levdist(\fIa\fR, \fIb\fR, \fIutf\fR)" 4
.IX Item "KyotoCabinet::levdist(a, b, utf)"

Calculate the levenshtein distance of two strings.

\&\f(CW@param\fR a one string.

\&\f(CW@param\fR b the other string.

\&\f(CW@param\fR utf flag to treat keys as \s-1UTF\-8\s0 strings.  If it is omitted, false is specified.

\&\f(CW@return\fR the levenshtein distance.
.SS "Class KyotoCabinet::Error"
.IX Subsection "Class KyotoCabinet::Error"
This class expresses error data.
.IP "\fIKyotoCabinet::Error::SUCCESS()\fR" 4
.IX Item "KyotoCabinet::Error::SUCCESS()"

error code: success
.IP "\fIKyotoCabinet::Error::NOIMPL()\fR" 4
.IX Item "KyotoCabinet::Error::NOIMPL()"

error code: not implemented
.IP "\fIKyotoCabinet::Error::INVALID()\fR" 4
.IX Item "KyotoCabinet::Error::INVALID()"

error code: invalid operation
.IP "\fIKyotoCabinet::Error::NOREPOS()\fR" 4
.IX Item "KyotoCabinet::Error::NOREPOS()"

error code: no repository
.IP "\fIKyotoCabinet::Error::NOPERM()\fR" 4
.IX Item "KyotoCabinet::Error::NOPERM()"

error code: no permission
.IP "\fIKyotoCabinet::Error::BROKEN()\fR" 4
.IX Item "KyotoCabinet::Error::BROKEN()"

error code: broken file
.IP "\fIKyotoCabinet::Error::DUPREC()\fR" 4
.IX Item "KyotoCabinet::Error::DUPREC()"

error code: record duplication
.IP "\fIKyotoCabinet::Error::NOREC()\fR" 4
.IX Item "KyotoCabinet::Error::NOREC()"

error code: no record
.IP "\fIKyotoCabinet::Error::LOGIC()\fR" 4
.IX Item "KyotoCabinet::Error::LOGIC()"

error code: logical inconsistency
.IP "\fIKyotoCabinet::Error::SYSTEM()\fR" 4
.IX Item "KyotoCabinet::Error::SYSTEM()"

error code: system error
.IP "\fIKyotoCabinet::Error::MISC()\fR" 4
.IX Item "KyotoCabinet::Error::MISC()"

error code: miscellaneous error
.ie n .IP "$err = new KyotoCabinet::Error(\fIcode\fR, \fImessage\fR)" 4
.el .IP "\f(CW$err\fR = new KyotoCabinet::Error(\fIcode\fR, \fImessage\fR)" 4
.IX Item "$err = new KyotoCabinet::Error(code, message)"

Create an error object.

\&\f(CW@param\fR code the error code.

\&\f(CW@param\fR message the supplement message.

\&\f(CW@return\fR the error object.
.ie n .IP "$err\->set(\fIcode\fR, \fImessage\fR)" 4
.el .IP "\f(CW$err\fR\->set(\fIcode\fR, \fImessage\fR)" 4
.IX Item "$err->set(code, message)"

Set the error information.

\&\f(CW@param\fR code the error code.

\&\f(CW@param\fR message the supplement message.

\&\f(CW@return\fR always undef.
.ie n .IP "$err\->\fIcode()\fR" 4
.el .IP "\f(CW$err\fR\->\fIcode()\fR" 4
.IX Item "$err->code()"

Get the error code.

\&\f(CW@return\fR the error code.
.ie n .IP "$err\->\fIname()\fR" 4
.el .IP "\f(CW$err\fR\->\fIname()\fR" 4
.IX Item "$err->name()"

Get the readable string of the code.

\&\f(CW@return\fR the readable string of the code.
.ie n .IP "$err\->\fImessage()\fR" 4
.el .IP "\f(CW$err\fR\->\fImessage()\fR" 4
.IX Item "$err->message()"

Get the supplement message.

\&\f(CW@return\fR the supplement message.
.ie n .IP "$err\->\fIstring()\fR" 4
.el .IP "\f(CW$err\fR\->\fIstring()\fR" 4
.IX Item "$err->string()"

Get the string expression.

\&\f(CW@return\fR the string expression.

\&\f(CW@note\fR This method overrides the stringification operator.
.ie n .IP "$err\->compare(\fIright\fR)" 4
.el .IP "\f(CW$err\fR\->compare(\fIright\fR)" 4
.IX Item "$err->compare(right)"

Compare itself with another error data.

\&\f(CW@param\fR right an error object or an error code.

\&\f(CW@return\fR true for the both operands are equal, or false if not.

\&\f(CW@note\fR This method overrides the comparison operator.
.SS "Class KyotoCabinet::Visitor"
.IX Subsection "Class KyotoCabinet::Visitor"
This class expresses the interface to access a record.
.IP "\fIKyotoCabinet::Visitor::NOP()\fR" 4
.IX Item "KyotoCabinet::Visitor::NOP()"

magic data: no operation
.IP "\fIKyotoCabinet::Visitor::REMOVE()\fR" 4
.IX Item "KyotoCabinet::Visitor::REMOVE()"

magic data: remove the record
.ie n .IP "$vis = new \fIKyotoCabinet::Visitor()\fR" 4
.el .IP "\f(CW$vis\fR = new \fIKyotoCabinet::Visitor()\fR" 4
.IX Item "$vis = new KyotoCabinet::Visitor()"

Create a visitor object.

\&\f(CW@return\fR the visitor object.
.ie n .IP "$vis\->visit_full(\fIkey\fR, \fIvalue\fR)" 4
.el .IP "\f(CW$vis\fR\->visit_full(\fIkey\fR, \fIvalue\fR)" 4
.IX Item "$vis->visit_full(key, value)"

Visit a record.

\&\f(CW@param\fR key the key.

\&\f(CW@param\fR value the value.

\&\f(CW@return\fR If it is a string, the value is replaced by the content.  If it is KyotoCabinet::Visitor::NOP, nothing is modified.  If it is KyotoCabinet::Visitor::REMOVE, the record is removed.
.ie n .IP "$vis\->visit_empty(\fIkey\fR)" 4
.el .IP "\f(CW$vis\fR\->visit_empty(\fIkey\fR)" 4
.IX Item "$vis->visit_empty(key)"

Visit a empty record space.

\&\f(CW@param\fR key the key.

\&\f(CW@return\fR If it is a string, the value is replaced by the content.  If it is KyotoCabinet::Visitor::NOP or KyotoCabinet::Visitor::REMOVE, nothing is modified.
.SS "Class KyotoCabinet::FileProcessor"
.IX Subsection "Class KyotoCabinet::FileProcessor"
This class expresses the interface to process the database file.
.ie n .IP "$fproc = new \fIKyotoCabinet::FileProcessor()\fR" 4
.el .IP "\f(CW$fproc\fR = new \fIKyotoCabinet::FileProcessor()\fR" 4
.IX Item "$fproc = new KyotoCabinet::FileProcessor()"

Create a file processor object.

\&\f(CW@return\fR the file processor object.
.ie n .IP "$fproc\->process(\fIpath\fR, \fIcount\fR, \fIsize\fR)" 4
.el .IP "\f(CW$fproc\fR\->process(\fIpath\fR, \fIcount\fR, \fIsize\fR)" 4
.IX Item "$fproc->process(path, count, size)"

Process the database file.

\&\f(CW@param\fR path the path of the database file.

\&\f(CW@param\fR count the number of records.

\&\f(CW@param\fR size the size of the available region.

\&\f(CW@return\fR true on success, or false on failure.
.SS "Class KyotoCabinet::Cursor"
.IX Subsection "Class KyotoCabinet::Cursor"
This class expresses the interface of cursor to indicate a record.
.ie n .IP "$cur = new \fIKyotoCabinet::Cursor()\fR" 4
.el .IP "\f(CW$cur\fR = new \fIKyotoCabinet::Cursor()\fR" 4
.IX Item "$cur = new KyotoCabinet::Cursor()"

Create a cursor object.

\&\f(CW@return\fR the cursor object.
.ie n .IP "$cur\->\fIdisable()\fR" 4
.el .IP "\f(CW$cur\fR\->\fIdisable()\fR" 4
.IX Item "$cur->disable()"

Disable the cursor.

\&\f(CW@return\fR always undef.

\&\f(CW@note\fR This method should be called explicitly when the cursor is no longer in use.
.ie n .IP "$cur\->accept(\fIvisitor\fR, \fIwritable\fR, \fIstep\fR)" 4
.el .IP "\f(CW$cur\fR\->accept(\fIvisitor\fR, \fIwritable\fR, \fIstep\fR)" 4
.IX Item "$cur->accept(visitor, writable, step)"

Accept a visitor to the current record.

\&\f(CW@param\fR visitor a visitor object which implements the Visitor interface.  It can be the reference to a function.

\&\f(CW@param\fR writable true for writable operation, or false for read-only operation.

\&\f(CW@param\fR step true to move the cursor to the next record, or false for no move.

\&\f(CW@return\fR true on success, or false on failure.

\&\f(CW@note\fR To avoid deadlock, any explicit database operation must not be performed in this method.
.ie n .IP "$cur\->set_value(\fIvalue\fR, \fIstep\fR)" 4
.el .IP "\f(CW$cur\fR\->set_value(\fIvalue\fR, \fIstep\fR)" 4
.IX Item "$cur->set_value(value, step)"

Set the value of the current record.

\&\f(CW@param\fR value the value.

\&\f(CW@param\fR step true to move the cursor to the next record, or false for no move.

\&\f(CW@return\fR true on success, or false on failure.
.ie n .IP "$cur\->\fIremove()\fR" 4
.el .IP "\f(CW$cur\fR\->\fIremove()\fR" 4
.IX Item "$cur->remove()"

Remove the current record.

\&\f(CW@return\fR true on success, or false on failure.

\&\f(CW@note\fR If no record corresponds to the key, false is returned.  The cursor is moved to the next record implicitly.
.ie n .IP "$cur\->get_key(\fIstep\fR)" 4
.el .IP "\f(CW$cur\fR\->get_key(\fIstep\fR)" 4
.IX Item "$cur->get_key(step)"

Get the key of the current record.

\&\f(CW@param\fR step true to move the cursor to the next record, or false for no move.

\&\f(CW@return\fR the key of the current record, or undef on failure.

\&\f(CW@note\fR If the cursor is invalidated, undef is returned.
.ie n .IP "$cur\->get_value(\fIstep\fR)" 4
.el .IP "\f(CW$cur\fR\->get_value(\fIstep\fR)" 4
.IX Item "$cur->get_value(step)"

Get the value of the current record.

\&\f(CW@param\fR step true to move the cursor to the next record, or false for no move.

\&\f(CW@return\fR the value of the current record, or undef on failure.

\&\f(CW@note\fR If the cursor is invalidated, undef is returned.
.ie n .IP "$cur\->get(\fIstep\fR)" 4
.el .IP "\f(CW$cur\fR\->get(\fIstep\fR)" 4
.IX Item "$cur->get(step)"

Get a pair of the key and the value of the current record.

\&\f(CW@param\fR step true to move the cursor to the next record, or false for no move.

\&\f(CW@return\fR a pair of the key and the value of the current record, or undef on failure.

\&\f(CW@note\fR If the cursor is invalidated, undef is returned.
.ie n .IP "$cur\->\fIseize()\fR" 4
.el .IP "\f(CW$cur\fR\->\fIseize()\fR" 4
.IX Item "$cur->seize()"

Get a pair of the key and the value of the current record and remove it atomically.

\&\f(CW@return\fR a pair of the key and the value of the current record, or undef on failure.

\&\f(CW@note\fR If the cursor is invalidated, undef is returned.  The cursor is moved to the next record implicitly.
.ie n .IP "$cur\->jump(\fIkey\fR)" 4
.el .IP "\f(CW$cur\fR\->jump(\fIkey\fR)" 4
.IX Item "$cur->jump(key)"

Jump the cursor to a record for forward scan.

\&\f(CW@param\fR key the key of the destination record.  If it is undef, the destination is the first record.

\&\f(CW@return\fR true on success, or false on failure.
.ie n .IP "$cur\->jump_back(\fIkey\fR)" 4
.el .IP "\f(CW$cur\fR\->jump_back(\fIkey\fR)" 4
.IX Item "$cur->jump_back(key)"

Jump the cursor to a record for backward scan.

\&\f(CW@param\fR key the key of the destination record.  If it is undef, the destination is the last record.

\&\f(CW@return\fR true on success, or false on failure.

\&\f(CW@note\fR This method is dedicated to tree databases.  Some database types, especially hash databases, will provide a dummy implementation.
.ie n .IP "$cur\->\fIstep()\fR" 4
.el .IP "\f(CW$cur\fR\->\fIstep()\fR" 4
.IX Item "$cur->step()"

Step the cursor to the next record.

\&\f(CW@return\fR true on success, or false on failure.
.ie n .IP "$cur\->\fIstep_back()\fR" 4
.el .IP "\f(CW$cur\fR\->\fIstep_back()\fR" 4
.IX Item "$cur->step_back()"

Step the cursor to the previous record.

\&\f(CW@return\fR true on success, or false on failure.

\&\f(CW@note\fR This method is dedicated to tree databases.  Some database types, especially hash databases, will provide a dummy implementation.
.ie n .IP "$cur\->\fIdb()\fR" 4
.el .IP "\f(CW$cur\fR\->\fIdb()\fR" 4
.IX Item "$cur->db()"

Get the database object.

\&\f(CW@return\fR the database object.
.ie n .IP "$cur\->\fIerror()\fR" 4
.el .IP "\f(CW$cur\fR\->\fIerror()\fR" 4
.IX Item "$cur->error()"

Get the last happened error.

\&\f(CW@return\fR the last happened error.
.ie n .IP "$cur\->\fIstring()\fR" 4
.el .IP "\f(CW$cur\fR\->\fIstring()\fR" 4
.IX Item "$cur->string()"

Get the string expression.

\&\f(CW@return\fR the string expression.

\&\f(CW@note\fR This method overrides the stringification operator.
.SS "Class KyotoCabinet::DB"
.IX Subsection "Class KyotoCabinet::DB"
This class expresses the interface of database abstraction.
.IP "\fIKyotoCabinet::DB::OREADER()\fR" 4
.IX Item "KyotoCabinet::DB::OREADER()"

open mode: open as a reader
.IP "\fIKyotoCabinet::DB::OWRITER()\fR" 4
.IX Item "KyotoCabinet::DB::OWRITER()"

open mode: open as a writer
.IP "\fIKyotoCabinet::DB::OCREATE()\fR" 4
.IX Item "KyotoCabinet::DB::OCREATE()"

open mode: writer creating
.IP "\fIKyotoCabinet::DB::OTRUNCATE()\fR" 4
.IX Item "KyotoCabinet::DB::OTRUNCATE()"

open mode: writer truncating
.IP "\fIKyotoCabinet::DB::OAUTOTRAN()\fR" 4
.IX Item "KyotoCabinet::DB::OAUTOTRAN()"

open mode: auto transaction
.IP "\fIKyotoCabinet::DB::OAUTOSYNC()\fR" 4
.IX Item "KyotoCabinet::DB::OAUTOSYNC()"

open mode: auto synchronization
.IP "\fIKyotoCabinet::DB::ONOLOCK()\fR" 4
.IX Item "KyotoCabinet::DB::ONOLOCK()"

open mode: open without locking
.IP "\fIKyotoCabinet::DB::OTRYLOCK()\fR" 4
.IX Item "KyotoCabinet::DB::OTRYLOCK()"

open mode: lock without blocking
.IP "\fIKyotoCabinet::DB::ONOREPAIR()\fR" 4
.IX Item "KyotoCabinet::DB::ONOREPAIR()"

open mode: open without auto repair
.IP "\fIKyotoCabinet::DB::MSET()\fR" 4
.IX Item "KyotoCabinet::DB::MSET()"

merge mode: overwrite the existing value
.IP "\fIKyotoCabinet::DB::MADD()\fR" 4
.IX Item "KyotoCabinet::DB::MADD()"

merge mode: keep the existing value
.IP "\fIKyotoCabinet::DB::MREPLACE()\fR" 4
.IX Item "KyotoCabinet::DB::MREPLACE()"

merge mode: modify the existing record only
.IP "\fIKyotoCabinet::DB::MAPPEND()\fR" 4
.IX Item "KyotoCabinet::DB::MAPPEND()"

merge mode: append the new value
.ie n .IP "$db = new \fIKyotoCabinet::DB()\fR" 4
.el .IP "\f(CW$db\fR = new \fIKyotoCabinet::DB()\fR" 4
.IX Item "$db = new KyotoCabinet::DB()"

Create a database object.

\&\f(CW@return\fR the database object.
.ie n .IP "$db\->\fIerror()\fR" 4
.el .IP "\f(CW$db\fR\->\fIerror()\fR" 4
.IX Item "$db->error()"

Get the last happened error.

\&\f(CW@return\fR the last happened error.
.ie n .IP "$db\->open(\fIpath\fR, \fImode\fR)" 4
.el .IP "\f(CW$db\fR\->open(\fIpath\fR, \fImode\fR)" 4
.IX Item "$db->open(path, mode)"

Open a database file.

\&\f(CW@param\fR path the path of a database file.  If it is \*(L"\-\*(R", the database will be a prototype hash database.  If it is \*(L"+\*(R", the database will be a prototype tree database.  If it is \*(L":\*(R", the database will be a stash database.  If it is \*(L"*\*(R", the database will be a cache hash database.  If it is \*(L"%\*(R", the database will be a cache tree database.  If its suffix is \*(L".kch\*(R", the database will be a file hash database.  If its suffix is \*(L".kct\*(R", the database will be a file tree database.  If its suffix is \*(L".kcd\*(R", the database will be a directory hash database.  If its suffix is \*(L".kcf\*(R", the database will be a directory tree database.  If its suffix is \*(L".kcx\*(R", the database will be a plain text database.  Otherwise, this function fails.  Tuning parameters can trail the name, separated by \*(L"#\*(R".  Each parameter is composed of the name and the value, separated by \*(L"=\*(R".  If the \*(L"type\*(R" parameter is specified, the database type is determined by the value in \*(L"\-\*(R", \*(L"+\*(R", \*(L":\*(R", \*(L"*\*(R", \*(L"%\*(R", \*(L"kch\*(R", \*(L"kct\*(R", \*(L"kcd\*(R", kcf\*(L", and \*(R"kcx\*(L".  All database types support the logging parameters of \*(R"log\*(L", \*(R"logkinds\*(L", and \*(R"logpx\*(L".  The prototype hash database and the prototype tree database do not support any other tuning parameter.  The stash database supports \*(R"bnum\*(L".  The cache hash database supports \*(R"opts\*(L", \*(R"bnum\*(L", \*(R"zcomp\*(L", \*(R"capcnt\*(L", \*(R"capsiz\*(L", and \*(R"zkey\*(L".  The cache tree database supports all parameters of the cache hash database except for capacity limitation, and supports \*(R"psiz\*(L", \*(R"rcomp\*(L", \*(R"pccap\*(L" in addition.  The file hash database supports \*(R"apow\*(L", \*(R"fpow\*(L", \*(R"opts\*(L", \*(R"bnum\*(L", \*(R"msiz\*(L", \*(R"dfunit\*(L", \*(R"zcomp\*(L", and \*(R"zkey\*(L".  The file tree database supports all parameters of the file hash database and \*(R"psiz\*(L", \*(R"rcomp\*(L", \*(R"pccap\*(L" in addition.  The directory hash database supports \*(R"opts\*(L", \*(R"zcomp\*(L", and \*(R"zkey\*(L".  The directory tree database supports all parameters of the directory hash database and \*(R"psiz\*(L", \*(R"rcomp\*(L", \*(R"pccap\*(L" in addition.  The plain text database does not support any other tuning parameter.

\&\f(CW@param\fR mode the connection mode.  KyotoCabinet::DB::OWRITER as a writer, KyotoCabinet::DB::OREADER as a reader.  The following may be added to the writer mode by bitwise-or: KyotoCabinet::DB::OCREATE, which means it creates a new database if the file does not exist, KyotoCabinet::DB::OTRUNCATE, which means it creates a new database regardless if the file exists, KyotoCabinet::DB::OAUTOTRAN, which means each updating operation is performed in implicit transaction, KyotoCabinet::DB::OAUTOSYNC, which means each updating operation is followed by implicit synchronization with the file system.  The following may be added to both of the reader mode and the writer mode by bitwise-or: KyotoCabinet::DB::ONOLOCK, which means it opens the database file without file locking, KyotoCabinet::DB::OTRYLOCK, which means locking is performed without blocking, KyotoCabinet::DB::ONOREPAIR, which means the database file is not repaired implicitly even if file destruction is detected.

\&\f(CW@return\fR true on success, or false on failure.

\&\f(CW@note\fR The tuning parameter \*(R"log\*(L" is for the original \*(R"tune_logger\*(L" and the value specifies the path of the log file, or \*(R"\-\*(L" for the standard output, or \*(R"+\*(L" for the standard error.  \*(R"logkinds\*(L" specifies kinds of logged messages and the value can be \*(R"debug\*(L", \*(R"info\*(L", \*(R"warn\*(L", or \*(R"error\*(L".  \*(R"logpx\*(L" specifies the prefix of each log message.  \*(R"opts\*(L" is for \*(R"tune_options\*(L" and the value can contain \*(R"s\*(L" for the small option, \*(R"l\*(L" for the linear option, and \*(R"c\*(L" for the compress option.  \*(R"bnum\*(L" corresponds to \*(R"tune_bucket\*(L".  \*(R"zcomp\*(L" is for \*(R"tune_compressor\*(L" and the value can be \*(R"zlib\*(L" for the \s-1ZLIB\s0 raw compressor, \*(R"def\*(L" for the \s-1ZLIB\s0 deflate compressor, \*(R"gz\*(L" for the \s-1ZLIB\s0 gzip compressor, \*(R"lzo\*(L" for the \s-1LZO\s0 compressor, \*(R"lzma\*(L" for the \s-1LZMA\s0 compressor, or \*(R"arc\*(L" for the Arcfour cipher.  \*(R"zkey\*(L" specifies the cipher key of the compressor.  \*(R"capcnt\*(L" is for \*(R"cap_count\*(L".  \*(R"capsiz\*(L" is for \*(R"cap_size\*(L".  \*(R"psiz\*(L" is for \*(R"tune_page\*(L".  \*(R"rcomp\*(L" is for \*(R"tune_comparator\*(L" and the value can be \*(R"lex\*(L" for the lexical comparator, \*(R"dec\*(L" for the decimal comparator, \*(R"lexdesc\*(L" for the lexical descending comparator, or \*(R"decdesc\*(L" for the decimal descending comparator.  \*(R"pccap\*(L" is for \*(R"tune_page_cache\*(L".  \*(R"apow\*(L" is for \*(R"tune_alignment\*(L".  \*(R"fpow\*(L" is for \*(R"tune_fbp\*(L".  \*(R"msiz\*(L" is for \*(R"tune_map\*(L".  \*(R"dfunit\*(L" is for \*(R"tune_defrag".  Every opened database must be closed by the PolyDB::close method when it is no longer in use.  It is not allowed for two or more database objects in the same process to keep their connections to the same database file at the same time.
.ie n .IP "$db\->\fIclose()\fR" 4
.el .IP "\f(CW$db\fR\->\fIclose()\fR" 4
.IX Item "$db->close()"

Close the database file.

\&\f(CW@return\fR true on success, or false on failure.
.ie n .IP "$db\->accept(\fIkey\fR, \fIvisitor\fR, \fIwritable\fR)" 4
.el .IP "\f(CW$db\fR\->accept(\fIkey\fR, \fIvisitor\fR, \fIwritable\fR)" 4
.IX Item "$db->accept(key, visitor, writable)"

Accept a visitor to a record.

\&\f(CW@param\fR key the key.

\&\f(CW@param\fR visitor a visitor object which implements the Visitor interface.  It can be the reference to a function.

\&\f(CW@param\fR writable true for writable operation, or false for read-only operation.

\&\f(CW@return\fR true on success, or false on failure.

\&\f(CW@note\fR To avoid deadlock, any explicit database operation must not be performed in this method.
.ie n .IP "$db\->accept_bulk(\fIkeys\fR, \fIvisitor\fR, \fIwritable\fR)" 4
.el .IP "\f(CW$db\fR\->accept_bulk(\fIkeys\fR, \fIvisitor\fR, \fIwritable\fR)" 4
.IX Item "$db->accept_bulk(keys, visitor, writable)"

Accept a visitor to a record.

\&\f(CW@param\fR keys the reference to an array of the keys.

\&\f(CW@param\fR visitor a visitor object which implements the Visitor interface.  It can be the reference to a function.

\&\f(CW@param\fR writable true for writable operation, or false for read-only operation.

\&\f(CW@return\fR true on success, or false on failure.

\&\f(CW@note\fR To avoid deadlock, any explicit database operation must not be performed in this method.
.ie n .IP "$db\->iterate(\fIvisitor\fR, \fIwritable\fR)" 4
.el .IP "\f(CW$db\fR\->iterate(\fIvisitor\fR, \fIwritable\fR)" 4
.IX Item "$db->iterate(visitor, writable)"

Iterate to accept a visitor for each record.

\&\f(CW@param\fR visitor a visitor object which implements the Visitor interface.  It can be the reference to a function.

\&\f(CW@param\fR writable true for writable operation, or false for read-only operation.

\&\f(CW@return\fR true on success, or false on failure.

\&\f(CW@note\fR To avoid deadlock, any explicit database operation must not be performed in this method.
.ie n .IP "$db\->set(\fIkey\fR, \fIvalue\fR)" 4
.el .IP "\f(CW$db\fR\->set(\fIkey\fR, \fIvalue\fR)" 4
.IX Item "$db->set(key, value)"

Set the value of a record.

\&\f(CW@param\fR key the key.

\&\f(CW@param\fR value the value.

\&\f(CW@return\fR true on success, or false on failure.

\&\f(CW@note\fR If no record corresponds to the key, a new record is created.  If the corresponding record exists, the value is overwritten.
.ie n .IP "$db\->add(\fIkey\fR, \fIvalue\fR)" 4
.el .IP "\f(CW$db\fR\->add(\fIkey\fR, \fIvalue\fR)" 4
.IX Item "$db->add(key, value)"

Add a record.

\&\f(CW@param\fR key the key.

\&\f(CW@param\fR value the value.

\&\f(CW@return\fR true on success, or false on failure.

\&\f(CW@note\fR If no record corresponds to the key, a new record is created.  If the corresponding record exists, the record is not modified and false is returned.
.ie n .IP "$db\->replace(\fIkey\fR, \fIvalue\fR)" 4
.el .IP "\f(CW$db\fR\->replace(\fIkey\fR, \fIvalue\fR)" 4
.IX Item "$db->replace(key, value)"

Replace the value of a record.

\&\f(CW@param\fR key the key.

\&\f(CW@param\fR value the value.

\&\f(CW@return\fR true on success, or false on failure.

\&\f(CW@note\fR If no record corresponds to the key, no new record is created and false is returned.  If the corresponding record exists, the value is modified.
.ie n .IP "$db\->append(\fIkey\fR, \fIvalue\fR)" 4
.el .IP "\f(CW$db\fR\->append(\fIkey\fR, \fIvalue\fR)" 4
.IX Item "$db->append(key, value)"

Append the value of a record.

\&\f(CW@param\fR key the key.

\&\f(CW@param\fR value the value.

\&\f(CW@return\fR true on success, or false on failure.

\&\f(CW@note\fR If no record corresponds to the key, a new record is created.  If the corresponding record exists, the given value is appended at the end of the existing value.
.ie n .IP "$db\->increment(\fIkey\fR, \fInum\fR, \fIorig\fR)" 4
.el .IP "\f(CW$db\fR\->increment(\fIkey\fR, \fInum\fR, \fIorig\fR)" 4
.IX Item "$db->increment(key, num, orig)"

Add a number to the numeric integer value of a record.

\&\f(CW@param\fR key the key.

\&\f(CW@param\fR num the additional number.

\&\f(CW@param\fR orig the origin number if no record corresponds to the key.  If it is negative infinity and no record corresponds, this method fails.  If it is positive infinity, the value is set as the additional number regardless of the current value.

\&\f(CW@return\fR the result value, or undef on failure.

\&\f(CW@note\fR The value is serialized as an 8\-byte binary integer in big-endian order, not a decimal string.  If existing value is not 8\-byte, this method fails.
.ie n .IP "$db\->increment_double(\fIkey\fR, \fInum\fR, \fIorig\fR)" 4
.el .IP "\f(CW$db\fR\->increment_double(\fIkey\fR, \fInum\fR, \fIorig\fR)" 4
.IX Item "$db->increment_double(key, num, orig)"

Add a number to the numeric double value of a record.

\&\f(CW@param\fR key the key.

\&\f(CW@param\fR num the additional number.

\&\f(CW@param\fR orig the origin number if no record corresponds to the key.  If it is negative infinity and no record corresponds, this method fails.  If it is positive infinity, the value is set as the additional number regardless of the current value.

\&\f(CW@return\fR the result value, or undef on failure.

\&\f(CW@note\fR The value is serialized as an 16\-byte binary fixed-point number in big-endian order, not a decimal string.  If existing value is not 16\-byte, this method fails.
.ie n .IP "$db\->cas(\fIkey\fR, \fIoval\fR, \fInval\fR)" 4
.el .IP "\f(CW$db\fR\->cas(\fIkey\fR, \fIoval\fR, \fInval\fR)" 4
.IX Item "$db->cas(key, oval, nval)"

Perform compare-and-swap.

\&\f(CW@param\fR key the key.

\&\f(CW@param\fR oval the old value.  undef means that no record corresponds.

\&\f(CW@param\fR nval the new value.  undef means that the record is removed.

\&\f(CW@return\fR true on success, or false on failure.
.ie n .IP "$db\->remove(\fIkey\fR)" 4
.el .IP "\f(CW$db\fR\->remove(\fIkey\fR)" 4
.IX Item "$db->remove(key)"

Remove a record.

\&\f(CW@param\fR key the key.

\&\f(CW@return\fR true on success, or false on failure.

\&\f(CW@note\fR If no record corresponds to the key, false is returned.
.ie n .IP "$db\->get(\fIkey\fR)" 4
.el .IP "\f(CW$db\fR\->get(\fIkey\fR)" 4
.IX Item "$db->get(key)"

Retrieve the value of a record.

\&\f(CW@param\fR key the key.

\&\f(CW@return\fR the value of the corresponding record, or undef on failure.
.ie n .IP "$db\->check(\fIkey\fR)" 4
.el .IP "\f(CW$db\fR\->check(\fIkey\fR)" 4
.IX Item "$db->check(key)"

Check the existence of a record.

\&\f(CW@param\fR key the key.

\&\f(CW@return\fR the size of the value, or \-1 on failure.
.ie n .IP "$db\->seize(\fIkey\fR)" 4
.el .IP "\f(CW$db\fR\->seize(\fIkey\fR)" 4
.IX Item "$db->seize(key)"

Retrieve the value of a record and remove it atomically.

\&\f(CW@param\fR key the key.

\&\f(CW@return\fR the value of the corresponding record, or undef on failure.
.ie n .IP "$db\->set_bulk(\fIrecs\fR)" 4
.el .IP "\f(CW$db\fR\->set_bulk(\fIrecs\fR)" 4
.IX Item "$db->set_bulk(recs)"

Store records at once.

\&\f(CW@param\fR recs the reference to a hash of the records to store.

\&\f(CW@return\fR the number of stored records, or \-1 on failure.
.ie n .IP "$db\->remove_bulk(\fIkeys\fR)" 4
.el .IP "\f(CW$db\fR\->remove_bulk(\fIkeys\fR)" 4
.IX Item "$db->remove_bulk(keys)"

Remove records at once.

\&\f(CW@param\fR keys the reference to an array of the keys of the records to remove.

\&\f(CW@return\fR the number of removed records, or \-1 on failure.
.ie n .IP "$db\->get_bulk(\fIkeys\fR)" 4
.el .IP "\f(CW$db\fR\->get_bulk(\fIkeys\fR)" 4
.IX Item "$db->get_bulk(keys)"

Retrieve records at once.

\&\f(CW@param\fR keys the reference to an array of the keys of the records to retrieve.

\&\f(CW@return\fR the reference to a hash of retrieved records, or undef on failure.
.ie n .IP "$db\->\fIclear()\fR" 4
.el .IP "\f(CW$db\fR\->\fIclear()\fR" 4
.IX Item "$db->clear()"

Remove all records.

\&\f(CW@return\fR true on success, or false on failure.
.ie n .IP "$db\->synchronize(\fIhard\fR, \fIproc\fR)" 4
.el .IP "\f(CW$db\fR\->synchronize(\fIhard\fR, \fIproc\fR)" 4
.IX Item "$db->synchronize(hard, proc)"

Synchronize updated contents with the file and the device.

\&\f(CW@param\fR hard true for physical synchronization with the device, or false for logical synchronization with the file system.

\&\f(CW@param\fR proc a postprocessor object which implements the FileProcessor interface.  It can be the reference to a function.

\&\f(CW@return\fR true on success, or false on failure.

\&\f(CW@note\fR The operation of the processor is performed atomically and other threads accessing the same record are blocked.  To avoid deadlock, any explicit database operation must not be performed in this method.
.ie n .IP "$db\->occupy(\fIwritable\fR, \fIproc\fR)" 4
.el .IP "\f(CW$db\fR\->occupy(\fIwritable\fR, \fIproc\fR)" 4
.IX Item "$db->occupy(writable, proc)"

Occupy database by locking and do something meanwhile.

\&\f(CW@param\fR writable true to use writer lock, or false to use reader lock.

\&\f(CW@param\fR proc a processor object which implements the FileProcessor interface.  It can be the reference to a function.

\&\f(CW@return\fR true on success, or false on failure.

\&\f(CW@note\fR The operation of the processor is performed atomically and other threads accessing the same record are blocked.  To avoid deadlock, any explicit database operation must not be performed in this method.
.ie n .IP "$db\->copy(\fIdest\fR)" 4
.el .IP "\f(CW$db\fR\->copy(\fIdest\fR)" 4
.IX Item "$db->copy(dest)"

Create a copy of the database file.

\&\f(CW@param\fR dest the path of the destination file.

\&\f(CW@return\fR true on success, or false on failure.
.ie n .IP "$db\->begin_transaction(\fIhard\fR)" 4
.el .IP "\f(CW$db\fR\->begin_transaction(\fIhard\fR)" 4
.IX Item "$db->begin_transaction(hard)"

Begin transaction.

\&\f(CW@param\fR hard true for physical synchronization with the device, or false for logical synchronization with the file system.

\&\f(CW@return\fR true on success, or false on failure.
.ie n .IP "$db\->end_transaction(\fIcommit\fR)" 4
.el .IP "\f(CW$db\fR\->end_transaction(\fIcommit\fR)" 4
.IX Item "$db->end_transaction(commit)"

End transaction.

\&\f(CW@param\fR commit true to commit the transaction, or false to abort the transaction.

\&\f(CW@return\fR true on success, or false on failure.
.ie n .IP "$db\->transaction(\fIproc\fR, \fIhard\fR)" 4
.el .IP "\f(CW$db\fR\->transaction(\fIproc\fR, \fIhard\fR)" 4
.IX Item "$db->transaction(proc, hard)"

Perform entire transaction by a functor.

\&\f(CW@param\fR proc the functor of operations during transaction.  If the function returns true, the transaction is committed.  If the function returns false, the transaction is aborted.

\&\f(CW@param\fR hard true for physical synchronization with the device, or false for logical synchronization with the file system.

\&\f(CW@return\fR true on success, or false on failure.
.ie n .IP "$db\->dump_snapshot(\fIdest\fR)" 4
.el .IP "\f(CW$db\fR\->dump_snapshot(\fIdest\fR)" 4
.IX Item "$db->dump_snapshot(dest)"

Dump records into a snapshot file.

\&\f(CW@param\fR dest the name of the destination file.

\&\f(CW@return\fR true on success, or false on failure.
.ie n .IP "$db\->load_snapshot(\fIsrc\fR)" 4
.el .IP "\f(CW$db\fR\->load_snapshot(\fIsrc\fR)" 4
.IX Item "$db->load_snapshot(src)"

Load records from a snapshot file.

\&\f(CW@param\fR src the name of the source file.

\&\f(CW@return\fR true on success, or false on failure.
.ie n .IP "$db\->\fIcount()\fR" 4
.el .IP "\f(CW$db\fR\->\fIcount()\fR" 4
.IX Item "$db->count()"

Get the number of records.

\&\f(CW@return\fR the number of records, or \-1 on failure.
.ie n .IP "$db\->\fIsize()\fR" 4
.el .IP "\f(CW$db\fR\->\fIsize()\fR" 4
.IX Item "$db->size()"

Get the size of the database file.

\&\f(CW@return\fR the size of the database file in bytes, or \-1 on failure.
.ie n .IP "$db\->\fIpath()\fR" 4
.el .IP "\f(CW$db\fR\->\fIpath()\fR" 4
.IX Item "$db->path()"

Get the path of the database file.

\&\f(CW@return\fR the path of the database file, or undef on failure.
.ie n .IP "$db\->\fIstatus()\fR" 4
.el .IP "\f(CW$db\fR\->\fIstatus()\fR" 4
.IX Item "$db->status()"

Get the miscellaneous status information.

\&\f(CW@return\fR the reference to a hash object of the status information, or undef on failure.
.ie n .IP "$db\->match_prefix(\fIprefix\fR, \fImax\fR)" 4
.el .IP "\f(CW$db\fR\->match_prefix(\fIprefix\fR, \fImax\fR)" 4
.IX Item "$db->match_prefix(prefix, max)"

Get keys matching a prefix string.

\&\f(CW@param\fR prefix the prefix string.

\&\f(CW@param\fR max the maximum number to retrieve.  If it is negative, no limit is specified.

\&\f(CW@return\fR the reference to an array of matching keys, or undef on failure.
.ie n .IP "$db\->match_regex(\fIregex\fR, \fImax\fR)" 4
.el .IP "\f(CW$db\fR\->match_regex(\fIregex\fR, \fImax\fR)" 4
.IX Item "$db->match_regex(regex, max)"

Get keys matching a regular expression string.

\&\f(CW@param\fR regex the regular expression string.

\&\f(CW@param\fR max the maximum number to retrieve.  If it is negative, no limit is specified.

\&\f(CW@return\fR the reference to an array of matching keys, or undef on failure.
.ie n .IP "$db\->match_similar(\fIorigin\fR, \fIrange\fR, \fIutf\fR, \fImax\fR)" 4
.el .IP "\f(CW$db\fR\->match_similar(\fIorigin\fR, \fIrange\fR, \fIutf\fR, \fImax\fR)" 4
.IX Item "$db->match_similar(origin, range, utf, max)"

Get keys similar to a string in terms of the levenshtein distance.

\&\f(CW@param\fR origin the origin string.

\&\f(CW@param\fR range the maximum distance of keys to adopt.

\&\f(CW@param\fR utf flag to treat keys as \s-1UTF\-8\s0 strings.

\&\f(CW@param\fR max the maximum number to retrieve.  If it is negative, no limit is specified.

\&\f(CW@return\fR the reference to an array of matching keys, or undef on failure.
.ie n .IP "$db\->merge(\fIsrcary\fR, \fImode\fR)" 4
.el .IP "\f(CW$db\fR\->merge(\fIsrcary\fR, \fImode\fR)" 4
.IX Item "$db->merge(srcary, mode)"

Merge records from other databases.

\&\f(CW@param\fR srcary the reference to an array of the source detabase objects.

\&\f(CW@param\fR mode the merge mode.  KyotoCabinet::DB::MSET to overwrite the existing value, KyotoCabinet::DB::MADD to keep the existing value, KyotoCabinet::DB::MAPPEND to append the new value.

\&\f(CW@return\fR true on success, or false on failure.
.ie n .IP "$db\->\fIcursor()\fR" 4
.el .IP "\f(CW$db\fR\->\fIcursor()\fR" 4
.IX Item "$db->cursor()"

Create a cursor object.

\&\f(CW@return\fR the return value is the created cursor object.  Each cursor should be disabled with the Cursor::disable method when it is no longer in use.
.ie n .IP "$db\->cursor_process(\fIproc\fR)" 4
.el .IP "\f(CW$db\fR\->cursor_process(\fIproc\fR)" 4
.IX Item "$db->cursor_process(proc)"

Process a cursor by a functor.

\&\f(CW@param\fR proc the functor of operations for the cursor.  The cursor is disabled implicitly after the block.

\&\f(CW@return\fR always undef.
.ie n .IP "$db\->\fIstring()\fR" 4
.el .IP "\f(CW$db\fR\->\fIstring()\fR" 4
.IX Item "$db->string()"

Get the string expression.

\&\f(CW@return\fR the string expression.

\&\f(CW@note\fR This method overrides the stringification operator.
.IP "KyotoCabinet::DB\->process(\fIproc\fR, \fIpath\fR, \fImode\fR)" 4
.IX Item "KyotoCabinet::DB->process(proc, path, mode)"

Process a database by a functor.

\&\f(CW@param\fR proc the functor to process the database, whose object is passd as the parameter.

\&\f(CW@param\fR path the same to the one of the open method.

\&\f(CW@param\fR mode the same to the one of the open method.

\&\f(CW@return\fR undef on success, or an error object on failure.
.SS "Tying functions of KyotoCabinet::DB"
.IX Subsection "Tying functions of KyotoCabinet::DB"
.ie n .IP "$db = tie(%db, ""KyotoCabinet::DB"", \fIpath\fR, \fImode\fR)" 4
.el .IP "\f(CW$db\fR = tie(%db, ``KyotoCabinet::DB'', \fIpath\fR, \fImode\fR)" 4
.IX Item "$db = tie(%db, KyotoCabinet::DB, path, mode)"

Tie a hash variable to a database file.

\&\f(CW@param\fR path the path of a database file.

\&\f(CW@param\fR mode the connection mode.

\&\f(CW@return\fR the inner database object, or undef on failure.

\&\f(CW@note\fR The database file is opened implicitly with the given parameters.
.IP "untie(%db)" 4
.IX Item "untie(%db)"

Untie a hash variable from the database file.

\&\f(CW@return\fR always undef.

\&\f(CW@note\fR The database file is closed implicitly.
.ie n .IP "$db{\fIkey\fR}" 4
.el .IP "\f(CW$db\fR{\fIkey\fR}" 4
.IX Item "$db{key}"

Retrieve the value of a record.

\&\f(CW@param\fR key the key.

\&\f(CW@return\fR the value of the corresponding record, or undef on failure.
.ie n .IP "$db{\fIkey\fR} = \fIvalue\fR" 4
.el .IP "\f(CW$db\fR{\fIkey\fR} = \fIvalue\fR" 4
.IX Item "$db{key} = value"

Store a record.

\&\f(CW@param\fR key the key.

\&\f(CW@param\fR value the value.

\&\f(CW@return\fR true on success, or false on failure.
.IP "delete($db{\fIkey\fR})" 4
.IX Item "delete($db{key})"

Remove a record.

\&\f(CW@param\fR key the key.

\&\f(CW@return\fR true on success, or false on failure.
.ie n .IP "%db = ()" 4
.el .IP "\f(CW%db\fR = ()" 4
.IX Item "%db = ()"

Remove all records.

\&\f(CW@return\fR true on success, or false on failure.
.IP "exists($db{\fIkey\fR})" 4
.IX Item "exists($db{key})"

Check whether a record corrsponding a key exists.

\&\f(CW@return\fR true if the key exists, or false if not.
.IP "(the iterator)" 4
.IX Item "(the iterator)"

The inner methods `\s-1FIRSTKEY\s0' and `\s-1NEXTKEY\s0' are also implemented so that you can use the tying functions `each', `keys', and so on.
.SH "LICENSE"
.IX Header "LICENSE"
.Vb 2
\& Copyright (C) 2009\-2010 FAL Labs
\& All rights reserved.
.Ve
.PP
Kyoto Cabinet is free software: you can redistribute it and/or modify it under the terms of the \s-1GNU\s0 General Public License as published by the Free Software Foundation, either version 3 of the License, or any later version.
.PP
Kyoto Cabinet is distributed in the hope that it will be useful, but \s-1WITHOUT ANY WARRANTY\s0; without even the implied warranty of \s-1MERCHANTABILITY\s0 or \s-1FITNESS FOR A PARTICULAR PURPOSE. \s0 See the \s-1GNU\s0 General Public License for more details.
