.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Test::Stream::Plugin::Compare 3"
.TH Test::Stream::Plugin::Compare 3 "2015-10-13" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Test::Stream::Plugin::Compare \- Tools for comparing deep data structures.
.SH "EXPERIMENTAL CODE WARNING"
.IX Header "EXPERIMENTAL CODE WARNING"
\&\fBThis is an experimental release!\fR Test-Stream, and all its components are
still in an experimental phase. This dist has been released to cpan in order to
allow testers and early adopters the chance to write experimental new tools
with it, or to add experimental support for it into old tools.
.PP
\&\fB\s-1PLEASE DO NOT COMPLETELY CONVERT OLD TOOLS YET\s0\fR. This experimental release is
very likely to see a lot of code churn. \s-1API\s0's may break at any time.
Test-Stream should \s-1NOT\s0 be depended on by any toolchain level tools until the
experimental phase is over.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Test::More had \f(CW\*(C`is_deeply()\*(C'\fR. This library is the Test::Stream version.
This library can be used to compare data structures. This library goes a step
further though, it provides tools for building a data structure specification
against which you can verify your data. There are both 'strict' and 'relaxed'
versions of the tools.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Test::Stream \*(AqCompare\*(Aq;
\&
\&    # Hash for demonstration purposes
\&    my $some_hash = {a => 1, b => 2, c => 3};
\&
\&    # Strict checking, everything must match
\&    is(
\&        $some_hash,
\&        {a => 1, b => 2, c => 3},
\&        "The hash we got matches our expectations"
\&    );
\&
\&    # Relaxed Checking, only fields we care about are checked, and we can use a
\&    # regex to approximate a field.
\&    like(
\&        $some_hash,
\&        {a => 1, b => qr/\ed+/},
\&        "\*(Aqa\*(Aq is 1, \*(Aqb\*(Aq is an integer, we don\*(Aqt care about \*(Aqc\*(Aq."
\&    );
.Ve
.SH "COMPARISON TOOLS"
.IX Header "COMPARISON TOOLS"
.ie n .IP "$bool = is($got, $expect)" 4
.el .IP "\f(CW$bool\fR = is($got, \f(CW$expect\fR)" 4
.IX Item "$bool = is($got, $expect)"
.PD 0
.ie n .IP "$bool = is($got, $expect, $name)" 4
.el .IP "\f(CW$bool\fR = is($got, \f(CW$expect\fR, \f(CW$name\fR)" 4
.IX Item "$bool = is($got, $expect, $name)"
.ie n .IP "$bool = is($got, $expect, $name, @diag)" 4
.el .IP "\f(CW$bool\fR = is($got, \f(CW$expect\fR, \f(CW$name\fR, \f(CW@diag\fR)" 4
.IX Item "$bool = is($got, $expect, $name, @diag)"
.PD
\&\f(CW$got\fR is the data structure you want to check. \f(CW$expect\fR is what you want
\&\f(CW$got\fR to look like. \f(CW$name\fR is an optional name for the test. \f(CW@diag\fR is
optional diagnostics messages that will be printed to \s-1STDERR\s0 in event of
failure, they will not be displayed when the comparison is successful. The
boolean true/false result of the comparison is returned.
.Sp
This is the strict checker. The strict checker requires a perfect match between
\&\f(CW$got\fR and \f(CW$expect\fR. All hash fields must be specfied, all array items must
be present, etc. All non\-scalar/hash/array/regex references must be identical
(same memory address). Scalar, hash and array references will be traversed and
compared. Regex references will be compared to see if they have the same
pattern.
.Sp
.Vb 5
\&    is(
\&        $some_hash,
\&        {a => 1, b => 2, c => 3},
\&        "The hash we got matches our expectations"
\&    );
.Ve
.Sp
The only exception to strictness is when it is given an \f(CW$expect\fR object that
was built from a specification, in which case the specification determines the
strictness. Strictness only applies to literal values/references that are
provided and converted to a specification for you.
.Sp
.Vb 9
\&    is(
\&        $some_hash,
\&        hash {    # Note: the hash function is not exported by default
\&            field a => 1;
\&            field b => match(qr/\ed+/);    # Note: The match function is not exported by default
\&            # Don\*(Aqt care about other fields.
\&        },
\&        "The hash comparison is not strict"
\&    );
.Ve
.Sp
This works for both deep and shallow structures. For instance you can use this
to compare 2 strings:
.Sp
.Vb 1
\&    is(\*(Aqfoo\*(Aq, \*(Aqfoo\*(Aq, "strings match");
.Ve
.Sp
\&\fBNote\fR: This is not the tool to use if you want to check if 2 references are
the same exact reference, use \f(CW\*(C`ref_is()\*(C'\fR from the
Test::Stream::Plugin::Core plugin instead. \fIMost\fR of the time this will
work as well, however there are problems if your reference contains a cyle and
refers back to itself at some point, if this happens an exception will be
thrown to break an otherwise infinite recursion.
.ie n .IP "like($got, $expect)" 4
.el .IP "like($got, \f(CW$expect\fR)" 4
.IX Item "like($got, $expect)"
.PD 0
.ie n .IP "like($got, $expect, $name)" 4
.el .IP "like($got, \f(CW$expect\fR, \f(CW$name\fR)" 4
.IX Item "like($got, $expect, $name)"
.ie n .IP "like($got, $expect, $name, @diag)" 4
.el .IP "like($got, \f(CW$expect\fR, \f(CW$name\fR, \f(CW@diag\fR)" 4
.IX Item "like($got, $expect, $name, @diag)"
.PD
\&\f(CW$got\fR is the data structure you want to check. \f(CW$expect\fR is what you want
\&\f(CW$got\fR to look like. \f(CW$name\fR is an optional name for the test. \f(CW@diag\fR is
optional diagnostics messages that will be printed to \s-1STDERR\s0 in event of
failure, they will not be displayed when the comparison is successful. The
boolean true/false result of the comparison is returned.
.Sp
This is the relaxed checker. This will ignore hash keys or array indexes that
you do not actually specify in your \f(CW$expect\fR structure. In addition regex and
sub references will be used as validators. If you provide a regex using
\&\f(CW\*(C`qr/.../\*(C'\fR, the regex itself will be used to validate the corresponding value
in the \f(CW$got\fR structure. The same is true for coderefs, the value is passed in
as the first argument (and in \f(CW$_\fR) and the sub should return a boolean value.
.Sp
.Vb 5
\&    like(
\&        $some_hash,
\&        {a => 1, b => qr/\ed+/},
\&        "\*(Aqa\*(Aq is 1, \*(Aqb\*(Aq is an integer, we don\*(Aqt care about other fields"
\&    );
.Ve
.Sp
This works for both deep and shallow structures. For instance you can use this
to compare 2 strings:
.Sp
.Vb 1
\&    like(\*(Aqfoo bar\*(Aq, qr/^foo/, "string matches the pattern");
.Ve
.SS "\s-1QUICK CHECKS\s0"
.IX Subsection "QUICK CHECKS"
\&\fBNote: None of these are exported by default, you need to request them.\fR
.PP
Quick checks are a way to quickly generate a common value specification. These
can be used in structures passed into \f(CW\*(C`is\*(C'\fR and \f(CW\*(C`like\*(C'\fR through the \f(CW$expect\fR
argument.
.PP
Example:
.PP
.Vb 1
\&    is($foo, T(), \*(Aq$foo has a true value\*(Aq);
.Ve
.ie n .IP "$check = T()" 4
.el .IP "\f(CW$check\fR = T()" 4
.IX Item "$check = T()"
This verifies that the value in the corresponding \f(CW$got\fR structure is
true, any true value will do.
.Sp
.Vb 1
\&    is($foo, T(), \*(Aq$foo has a true value\*(Aq);
\&
\&    is(
\&        { a => \*(Aqxxx\*(Aq },
\&        { a => T() },
\&        "The \*(Aqa\*(Aq key is true"
\&    );
.Ve
.ie n .IP "$check = F()" 4
.el .IP "\f(CW$check\fR = F()" 4
.IX Item "$check = F()"
This verifies that the value in the corresponding \f(CW$got\fR structure is
false, any false value will do, \fBbut the value must exist\fR.
.Sp
.Vb 1
\&    is($foo, F(), \*(Aq$foo has a false value\*(Aq);
\&
\&    is(
\&        { a => 0 },
\&        { a => F() },
\&        "The \*(Aqa\*(Aq key is false"
\&    );
.Ve
.Sp
It is important to note that a non-existant value does not count as false, this
check will generate a failing test result:
.Sp
.Vb 5
\&    is(
\&        { a => 1 },
\&        { a => 1, b => F() },
\&        "The \*(Aqb\*(Aq key is false"
\&    );
.Ve
.Sp
This will produce the following output:
.Sp
.Vb 8
\&    not ok 1 \- The b key is false
\&    # Failed test "The \*(Aqb\*(Aq key is false"
\&    # at some_file.t line 10.
\&    # +\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-+
\&    # | PATH | GOT              | OP    | CHECK   |
\&    # +\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-+
\&    # | {b}  | <DOES NOT EXIST> | FALSE | FALSE() |
\&    # +\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-+
.Ve
.Sp
In perl you can have behavior that is different for a missing key vs a false
key, as such it was decided not to count a completely absent value as false.
See the \f(CW\*(C`DNE()\*(C'\fR shortcut below for checking that a field is missing.
.Sp
If you want to check for false and/or \s-1DNE\s0 use the \f(CW\*(C`FDNE()\*(C'\fR check.
.ie n .IP "$check = D()" 4
.el .IP "\f(CW$check\fR = D()" 4
.IX Item "$check = D()"
This is to verify that the value in the \f(CW$got\fR structure is defined. Any value
other than \f(CW\*(C`undef\*(C'\fR will pass.
.Sp
This will pass:
.Sp
.Vb 1
\&    is(\*(Aqfoo\*(Aq, D(), \*(Aqfoo is defined\*(Aq);
.Ve
.Sp
This will fail:
.Sp
.Vb 1
\&    is(undef, D(), \*(Aqfoo is defined\*(Aq);
.Ve
.ie n .IP "$check = \s-1\fIDNE\s0()\fR" 4
.el .IP "\f(CW$check\fR = \s-1\fIDNE\s0()\fR" 4
.IX Item "$check = DNE()"
This can be used to check that no value exists. This is useful to check the end
bound of an array, or to check that a key does not exist in a hash.
.Sp
These pass:
.Sp
.Vb 2
\&    is([\*(Aqa\*(Aq, \*(Aqb\*(Aq], [\*(Aqa\*(Aq, \*(Aqb\*(Aq, DNE()], "There is no third item in the array");
\&    is({a => 1}, {a => 1, b => DNE()}, "The \*(Aqb\*(Aq key does not exist in the hash");
.Ve
.Sp
These will fail:
.Sp
.Vb 2
\&    is([\*(Aqa\*(Aq, \*(Aqb\*(Aq, \*(Aqc\*(Aq], [\*(Aqa\*(Aq, \*(Aqb\*(Aq, DNE()], "No third item");
\&    is({a => 1, b => 2}, {a => 1, b => DNE()}, "No \*(Aqb\*(Aq key");
.Ve
.ie n .IP "$check = \s-1\fIFDNE\s0()\fR" 4
.el .IP "\f(CW$check\fR = \s-1\fIFDNE\s0()\fR" 4
.IX Item "$check = FDNE()"
This is a combination of \f(CW\*(C`F()\*(C'\fR and \f(CW\*(C`DNE()\*(C'\fR. This will pass for a false value,
or a non-existant value.
.SS "\s-1VALUE SPECIFICATIONS\s0"
.IX Subsection "VALUE SPECIFICATIONS"
\&\fBNote: None of these are exported by default, you need to request them.\fR
.ie n .IP "$check = match qr/.../" 4
.el .IP "\f(CW$check\fR = match qr/.../" 4
.IX Item "$check = match qr/.../"
Verify that the value matches the regex pattern.
.ie n .IP "$check = mismatch qr/.../" 4
.el .IP "\f(CW$check\fR = mismatch qr/.../" 4
.IX Item "$check = mismatch qr/.../"
Verify that the value does not match the regex pattern.
.ie n .IP "$check = validator(sub{ ... })" 4
.el .IP "\f(CW$check\fR = validator(sub{ ... })" 4
.IX Item "$check = validator(sub{ ... })"
.PD 0
.ie n .IP "$check = validator($NAME => sub{ ... })" 4
.el .IP "\f(CW$check\fR = validator($NAME => sub{ ... })" 4
.IX Item "$check = validator($NAME => sub{ ... })"
.ie n .IP "$check = validator($OP, $NAME, sub{ ... })" 4
.el .IP "\f(CW$check\fR = validator($OP, \f(CW$NAME\fR, sub{ ... })" 4
.IX Item "$check = validator($OP, $NAME, sub{ ... })"
.PD
The coderef is the only required argument. The coderef should check that the
value is what you expect, it should return a boolean true or false. Optionally
you can specify a name and operator that are used in diagnostics, they are also
provided to the sub itself as named parameters.
.Sp
Check the value using this sub. The sub gets the value in \f(CW$_\fR, as well it
recieved the value and several other items as named parameters.
.Sp
.Vb 2
\&    my $check = validator(sub {
\&        my %params = @_;
\&
\&        # These both work:
\&        my $got = $_;
\&        my $got = $params{got};
\&
\&        # Check if a value exists at all
\&        my $exists = $params{exists}
\&
\&        # What $OP (if any) did we specify when creating the validator
\&        my $operator = $params{operator};
\&
\&        # What name (if any) did we specify when creating the validator
\&        my $name = $params{name};
\&
\&        ...
\&
\&        return $bool;
\&    }
.Ve
.ie n .IP "$check = exact_ref($ref)" 4
.el .IP "\f(CW$check\fR = exact_ref($ref)" 4
.IX Item "$check = exact_ref($ref)"
Check that the value is exactly the same reference as the one provided.
.SS "\s-1SET BUILDERS\s0"
.IX Subsection "SET BUILDERS"
\&\fBNote: None of these are exported by default, you need to request them.\fR
.ie n .IP "my $check = check_set($check1, $check2, ...)" 4
.el .IP "my \f(CW$check\fR = check_set($check1, \f(CW$check2\fR, ...)" 4
.IX Item "my $check = check_set($check1, $check2, ...)"
Check that the value matches \s-1ALL\s0 of the specified checks.
.ie n .IP "my $check = in_set($check1, $check2, ...)" 4
.el .IP "my \f(CW$check\fR = in_set($check1, \f(CW$check2\fR, ...)" 4
.IX Item "my $check = in_set($check1, $check2, ...)"
Check that the value matches 1 \s-1OR MORE\s0 of the specified checks.
.ie n .IP "not_in_set($check1, $check2, ...)" 4
.el .IP "not_in_set($check1, \f(CW$check2\fR, ...)" 4
.IX Item "not_in_set($check1, $check2, ...)"
Check that the value \s-1DOES NOT\s0 match \s-1ANY\s0 of the specified checks.
.ie n .IP "check $thing" 4
.el .IP "check \f(CW$thing\fR" 4
.IX Item "check $thing"
Check that the value matches the specified thing.
.SS "\s-1HASH BUILDER\s0"
.IX Subsection "HASH BUILDER"
\&\fBNote: None of these are exported by default, you need to request them.\fR
.PP
.Vb 3
\&    $check = hash {
\&        field foo => 1;
\&        field bar => 2;
\&
\&        # Ensure the \*(Aqbaz\*(Aq keys does not even exist in the hash.
\&        field baz => DNE();
\&
\&        # Ensure the key exists, but is set to undef
\&        field bat => undef;
\&
\&        # Any check can be used
\&        field boo => $check;
\&
\&        ...
\&
\&        end(); # optional, enforces that no other keys are present.
\&    };
.Ve
.ie n .IP "$check = hash { ... }" 4
.el .IP "\f(CW$check\fR = hash { ... }" 4
.IX Item "$check = hash { ... }"
This is used to define a hash check.
.ie n .IP "field $NAME => $VAL" 4
.el .IP "field \f(CW$NAME\fR => \f(CW$VAL\fR" 4
.IX Item "field $NAME => $VAL"
.PD 0
.ie n .IP "field $NAME => $CHECK" 4
.el .IP "field \f(CW$NAME\fR => \f(CW$CHECK\fR" 4
.IX Item "field $NAME => $CHECK"
.PD
Specify a field check. This will check the hash key specified by \f(CW$NAME\fR and
ensure it matches the value in \f(CW$VAL\fR. You can put any valid check in \f(CW$VAL\fR,
such as the result of another call to \f(CW\*(C`array { ... }\*(C'\fR, \f(CW\*(C`DNE()\*(C'\fR, etc.
.Sp
\&\fBNote:\fR This function can only be used inside a hash builder sub, and must be
called in void context.
.IP "\fIend()\fR" 4
.IX Item "end()"
Enforce that no keys are found in the hash other than those specified. This is
essentually the 'use strict' of a hash check. This can be used anywhere in the
hash builder, though typically it is placed at the end.
.IP "\s-1\fIDNE\s0()\fR" 4
.IX Item "DNE()"
This is a handy check that can be used with \f(CW\*(C`field()\*(C'\fR to ensure that a field
(D)oes (N)not (E)xist.
.Sp
.Vb 1
\&    field foo => DNE();
.Ve
.SS "\s-1ARRAY BUILDER\s0"
.IX Subsection "ARRAY BUILDER"
\&\fBNote: None of these are exported by default, you need to request them.\fR
.PP
.Vb 3
\&    $check = hash {
\&        # Uses the next index, in this case index 0;
\&        item \*(Aqa\*(Aq;
\&
\&        # Gets index 1 automatically
\&        item \*(Aqb\*(Aq;
\&
\&        # Specify the index
\&        item 2 => \*(Aqc\*(Aq;
\&
\&        # We skipped index 3, which means we don\*(Aqt care what it is.
\&        item 4 => \*(Aqe\*(Aq;
\&
\&        # Gets index 5.
\&        item \*(Aqf\*(Aq;
\&
\&        # Remove any REMAINING items that contain 0\-9.
\&        filter_items { grep {m/\eD/} @_ };
\&
\&        # Of the remaining items (after the filter is applied) the next one
\&        # (which is now index 6) should be \*(Aqg\*(Aq.
\&        item 6 => \*(Aqg\*(Aq;
\&
\&        item 7 => DNE; # Ensure index 7 does not exist.
\&
\&        end(); # Ensure no other indexes exist.
\&    };
.Ve
.ie n .IP "$check = array { ... }" 4
.el .IP "\f(CW$check\fR = array { ... }" 4
.IX Item "$check = array { ... }"
.PD 0
.ie n .IP "item $VAL" 4
.el .IP "item \f(CW$VAL\fR" 4
.IX Item "item $VAL"
.ie n .IP "item $CHECK" 4
.el .IP "item \f(CW$CHECK\fR" 4
.IX Item "item $CHECK"
.ie n .IP "item $IDX, $VAL" 4
.el .IP "item \f(CW$IDX\fR, \f(CW$VAL\fR" 4
.IX Item "item $IDX, $VAL"
.ie n .IP "item $IDX, $CHECK" 4
.el .IP "item \f(CW$IDX\fR, \f(CW$CHECK\fR" 4
.IX Item "item $IDX, $CHECK"
.PD
Add an expected item to the array. If \f(CW$IDX\fR is not specified it will
automatically calculate it based on the last item added. You can skip indexes,
which means you do not want them to be checked.
.Sp
You can provide any value to check in \f(CW$VAL\fR, or you can provide any valid
check object.
.Sp
\&\fBNote:\fR Items \s-1MUST\s0 be added in order.
.Sp
\&\fBNote:\fR This function can only be used inside an array builder sub, and must
be called in void context.
.ie n .IP "filter_items { my @remaining = @_; ...; return @filtered }" 4
.el .IP "filter_items { my \f(CW@remaining\fR = \f(CW@_\fR; ...; return \f(CW@filtered\fR }" 4
.IX Item "filter_items { my @remaining = @_; ...; return @filtered }"
This function adds a filter, all items remaining in the array from the point
the filter is reached will be passed into the filter sub as arguments, the sub
should return only the items that should be checked.
.Sp
\&\fBNote:\fR This function can only be used inside an array builder sub, and must
be called in void context.
.IP "\fIend()\fR" 4
.IX Item "end()"
Enforce that there are no indexes after the last one specified. This will not
force checking of skipped indexes.
.IP "\s-1\fIDNE\s0()\fR" 4
.IX Item "DNE()"
This is a handy check that can be used with \f(CW\*(C`item()\*(C'\fR to ensure that an index
(D)oes (N)not (E)xist.
.Sp
.Vb 1
\&    item 5 => DNE();
.Ve
.SS "\s-1META BUILDER\s0"
.IX Subsection "META BUILDER"
\&\fBNote: None of these are exported by default, you need to request them.\fR
.PP
.Vb 6
\&    my $check = meta {
\&        prop blessed => \*(AqMy::Module\*(Aq; # Ensure value is blessed as our package
\&        prop reftype => \*(AqHASH\*(Aq;       # Ensure value is a blessed hash
\&        prop size    => 4;            # Check the number of hash keys
\&        prop this    => ...;          # Check the item itself
\&    };
.Ve
.IP "meta { ... }" 4
.IX Item "meta { ... }"
Build a meta check
.ie n .IP "prop $NAME => $VAL" 4
.el .IP "prop \f(CW$NAME\fR => \f(CW$VAL\fR" 4
.IX Item "prop $NAME => $VAL"
.PD 0
.ie n .IP "prop $NAME => $CHECK" 4
.el .IP "prop \f(CW$NAME\fR => \f(CW$CHECK\fR" 4
.IX Item "prop $NAME => $CHECK"
.PD
Check the property specified by \f(CW$name\fR against the value or check.
.Sp
Valid properties are:
.RS 4
.IP "'blessed'" 4
.IX Item "'blessed'"
What package (if any) the thing is blessed as.
.IP "'reftype'" 4
.IX Item "'reftype'"
Reference type (if any) the thing is.
.IP "'this'" 4
.IX Item "'this'"
The thing itself.
.IP "'size'" 4
.IX Item "'size'"
For array references this returns the number of elements. For hashes this
returns the number of keys. For everything else this returns undef.
.RE
.RS 4
.RE
.SS "\s-1OBJECT BUILDER\s0"
.IX Subsection "OBJECT BUILDER"
\&\fBNote: None of these are exported by default, you need to request them.\fR
.PP
.Vb 2
\&    my $check = object {
\&        call foo => 1; # Call the \*(Aqfoo\*(Aq method, check the result.
\&
\&        # Call the specified sub\-ref as a method on the object, check the
\&        # result. This is useful for wrapping methods that return multiple
\&        # values.
\&        call sub { [ shift\->get_list ] } => [...];
\&
\&        # This can be used to ensure a method does not exist.
\&        call nope => DNE();
\&
\&        # Check the hash key \*(Aqfoo\*(Aq of the underlying reference, this only works
\&        # on blessed hashes.
\&        field foo => 1;
\&
\&        # Check the value of index 4 on the underlying reference, this only
\&        # works on blessed arrays.
\&        item 4 => \*(Aqfoo\*(Aq;
\&
\&        # Check the meta\-property \*(Aqblessed\*(Aq of the object.
\&        prop blessed => \*(AqMy::Module\*(Aq;
\&
\&        # Ensure only the specified hash keys or array indexes are present in
\&        # the underlying hash. Has no effect on meta\-property checks or method
\&        # checks.
\&        end();
\&    };
.Ve
.ie n .IP "$check = object { ... }" 4
.el .IP "\f(CW$check\fR = object { ... }" 4
.IX Item "$check = object { ... }"
Specify an object check for use in comparisons.
.ie n .IP "call $METHOD_NAME => $RESULT" 4
.el .IP "call \f(CW$METHOD_NAME\fR => \f(CW$RESULT\fR" 4
.IX Item "call $METHOD_NAME => $RESULT"
.PD 0
.ie n .IP "call $METHOD_NAME => $CHECK" 4
.el .IP "call \f(CW$METHOD_NAME\fR => \f(CW$CHECK\fR" 4
.IX Item "call $METHOD_NAME => $CHECK"
.ie n .IP "call sub { ... }, $RESULT" 4
.el .IP "call sub { ... }, \f(CW$RESULT\fR" 4
.IX Item "call sub { ... }, $RESULT"
.ie n .IP "call sub { ... }, $CHECK" 4
.el .IP "call sub { ... }, \f(CW$CHECK\fR" 4
.IX Item "call sub { ... }, $CHECK"
.PD
Call the specified method (or coderef) and verify the result. The coderef form
us useful if you want to check a method that returns a list as it allows you to
wrap the result in a reference.
.Sp
.Vb 5
\&    my $ref = sub {
\&        my $self = shift;
\&        my @result = $self\->get_list;
\&        return \e@result;
\&    };
\&
\&    call $ref => [ ... ];
.Ve
.ie n .IP "field $NAME => $VAL" 4
.el .IP "field \f(CW$NAME\fR => \f(CW$VAL\fR" 4
.IX Item "field $NAME => $VAL"
Works just like it does for hash checks.
.ie n .IP "item $VAL" 4
.el .IP "item \f(CW$VAL\fR" 4
.IX Item "item $VAL"
.PD 0
.ie n .IP "item $IDX, $VAL" 4
.el .IP "item \f(CW$IDX\fR, \f(CW$VAL\fR" 4
.IX Item "item $IDX, $VAL"
.PD
Works just like it does for array checks.
.ie n .IP "prop $NAME => $VAL" 4
.el .IP "prop \f(CW$NAME\fR => \f(CW$VAL\fR" 4
.IX Item "prop $NAME => $VAL"
.PD 0
.ie n .IP "prop $NAME => $CHECK" 4
.el .IP "prop \f(CW$NAME\fR => \f(CW$CHECK\fR" 4
.IX Item "prop $NAME => $CHECK"
.PD
Check the property specified by \f(CW$name\fR against the value or check.
.Sp
Valid properties are:
.RS 4
.IP "'blessed'" 4
.IX Item "'blessed'"
What package (if any) the thing is blessed as.
.IP "'reftype'" 4
.IX Item "'reftype'"
Reference type (if any) the thing is.
.IP "'this'" 4
.IX Item "'this'"
The thing itself.
.IP "'size'" 4
.IX Item "'size'"
For array references this returns the number of elements. For hashes this
returns the number of keys. For everything else this returns undef.
.RE
.RS 4
.RE
.IP "\s-1\fIDNE\s0()\fR" 4
.IX Item "DNE()"
Can be used with \f(CW\*(C`item\*(C'\fR, or \f(CW\*(C`field\*(C'\fR to ensure the hash field or array index
does not exist. Can also be used with \f(CW\*(C`call\*(C'\fR to ensure a method does not
exist.
.IP "\fIend()\fR" 4
.IX Item "end()"
Turn on strict array/hash checking, that is ensure that no extra keys/indexes
are present.
.SS "\s-1EVENT BUILDER\s0"
.IX Subsection "EVENT BUILDER"
\&\fBNote: None of these are exported by default, you need to request them.\fR
.PP
Check that we got an event of a specified type:
.PP
.Vb 1
\&    my $check = event \*(AqOk\*(Aq;
.Ve
.PP
Check for details about the event:
.PP
.Vb 3
\&    my $check = event Ok => sub {
\&        # Check for a failure
\&        call pass => 0;
\&
\&        # Effective pass after TODO/SKIP are accounted for.
\&        call effective_pass => 1;
\&
\&        # Check the diagnostics
\&        call diag => [ match qr/Failed test foo/ ];
\&
\&        # Check the file the event reports to
\&        prop file => \*(Aqfoo.t\*(Aq;
\&
\&        # Check the line number the event reports o
\&        prop line => \*(Aq42\*(Aq;
\&
\&        # You can check the todo/skip values as well:
\&        prop skip => \*(Aqbroken\*(Aq;
\&        prop todo => \*(Aqfixme\*(Aq;
\&
\&        # Thread\-id and process\-id where event was generated
\&        prop tid => 123;
\&        prop pid => 123;
\&    };
.Ve
.PP
You can also provide a fully qualified event package with the '+' prefix:
.PP
.Vb 1
\&    my $check = event \*(Aq+My::Event\*(Aq => sub { ... }
.Ve
.ie n .IP "$check = event $TYPE;" 4
.el .IP "\f(CW$check\fR = event \f(CW$TYPE\fR;" 4
.IX Item "$check = event $TYPE;"
.PD 0
.ie n .IP "$check = event $TYPE => sub { ... };" 4
.el .IP "\f(CW$check\fR = event \f(CW$TYPE\fR => sub { ... };" 4
.IX Item "$check = event $TYPE => sub { ... };"
.PD
This works just like an object builder. In addition to supporting everything
the object check supports, you also have to specify the event type, and many
extra meta-properties are available.
.Sp
Extra properties are:
.RS 4
.IP "'file'" 4
.IX Item "'file'"
File name to which the event reports (for use in diagnostics).
.IP "'line'" 4
.IX Item "'line'"
Line number to which the event reports (for use in diagnostics).
.IP "'package'" 4
.IX Item "'package'"
Package to which the event reports (for use in diagnostics).
.IP "'subname'" 4
.IX Item "'subname'"
Sub that was called to generate the event (example: \f(CW\*(C`ok()\*(C'\fR).
.IP "'skip'" 4
.IX Item "'skip'"
Set to the skip value if the result was generated by skipping tests.
.IP "'todo'" 4
.IX Item "'todo'"
Set to the todo value if \s-1TODO\s0 was set when the event was generated.
.IP "'trace'" 4
.IX Item "'trace'"
The 'at file foo.t line 42' string that will be used in diagnostics.
.IP "'tid'" 4
.IX Item "'tid'"
Thread id in which the event was generated.
.IP "'pid'" 4
.IX Item "'pid'"
PRocess id in which the event was generated.
.RE
.RS 4
.RE
.SH "SOURCE"
.IX Header "SOURCE"
The source code repository for Test::Stream can be found at
\&\fIhttp://github.com/Test\-More/Test\-Stream/\fR.
.SH "MAINTAINERS"
.IX Header "MAINTAINERS"
.IP "Chad Granum <exodist@cpan.org>" 4
.IX Item "Chad Granum <exodist@cpan.org>"
.SH "AUTHORS"
.IX Header "AUTHORS"
.PD 0
.IP "Chad Granum <exodist@cpan.org>" 4
.IX Item "Chad Granum <exodist@cpan.org>"
.PD
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2015 Chad Granum <exodist7@gmail.com>.
.PP
This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
.PP
See \fIhttp://www.perl.com/perl/misc/Artistic.html\fR
